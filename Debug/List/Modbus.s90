///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.10.6.1378 for Atmel AVR          08/May/2022  01:27:23
// Copyright 1996-2018 IAR Systems AB.
//
//    Source file  =  
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Modbus\Modbus.cpp
//    Command line =  
//        -f C:\Users\ghost\AppData\Local\Temp\EW4B55.tmp
//        (--string_literals_in_flash
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Modbus\Modbus.cpp
//        --cpu=m48 -ms -o
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Debug\Obj -lB
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Debug\List
//        --initializers_in_flash --root_variables --no_cse --no_inline
//        --no_code_motion --no_cross_call --no_clustering --no_tbaa --debug
//        -DENABLE_BIT_DEFINITIONS -e -I
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\include\ -I
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Modbus\ --eeprom_size
//        256 --dlib --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 8.0\avr\LIB\DLIB\dlAVR-1s-ec_mul-n.h" -On --eec++)
//    Locale       =  Russian_RUS.1251
//    List file    =  
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Debug\List\Modbus.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME Modbus

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        ERROR
//NOTE: This module defines or uses C++ features that are not
//      accessible from assembler code. Assembling this file will
//      not produce an equivalent object file to the one produced
//      by the C++ compiler.

        EXTERN ?EPILOGUE_B14_L09
        EXTERN ?EPILOGUE_B4_L09
        EXTERN ?EPILOGUE_B5_L09
        EXTERN ?EPILOGUE_B7_L09
        EXTERN ?PROLOGUE14_L09
        EXTERN ?PROLOGUE4_L09
        EXTERN ?PROLOGUE5_L09
        EXTERN ?PROLOGUE7_L09
        EXTERN ?Register_R10_is_cg_reg
        EXTERN ?Register_R11_is_cg_reg
        EXTERN ?Register_R12_is_cg_reg
        EXTERN ?Register_R13_is_cg_reg
        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?Register_R5_is_cg_reg
        EXTERN ?Register_R6_is_cg_reg
        EXTERN ?Register_R7_is_cg_reg
        EXTERN ?Register_R8_is_cg_reg
        EXTERN ?Register_R9_is_cg_reg
        EXTERN ?S_SHL_L02
        EXTERN ?US_SHR_L02
        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBLIC ??ByteToBitPack
        PUBLIC ??ReadDiscreteInputs
        PUBLIC ??Reply
        PUBLIC ??ResponseException
        PUBLIC ??ResponseIsReceived
        PUBLIC ??SendMessage
        PUBLIC ??SlaveSet
        PUBLIC ??m_pui16HoldingRegisters
        PUBLIC ??m_pui16InputRegisters
        PUBLIC ??m_puiCoils
        PUBLIC ??m_puiDiscreteInputs
        PUBLIC ??m_puiRxBuffer
        PUBLIC ??m_puiTxBuffer
        PUBLIC ??m_uiCoilsNumber
        PUBLIC ??m_uiDiscreteInputsNumber
        PUBLIC ??m_uiFlowControl
        PUBLIC ??m_uiFunctionCode
        PUBLIC ??m_uiHoldingRegistersNumber
        PUBLIC ??m_uiInputRegistersNumber
        PUBLIC ??m_uiLastSystemTime
        PUBLIC ??m_uiMessageLength
        PUBLIC ??m_uiSlave
        PUBWEAK _A_ACSR
        PUBWEAK _A_ADC
        PUBWEAK _A_ADCSRA
        PUBWEAK _A_ADCSRB
        PUBWEAK _A_ADMUX
        PUBWEAK _A_ASSR
        PUBWEAK _A_CLKPR
        PUBWEAK _A_DDRB
        PUBWEAK _A_DDRC
        PUBWEAK _A_DDRD
        PUBWEAK _A_DIDR0
        PUBWEAK _A_DIDR1
        PUBWEAK _A_EEAR
        PUBWEAK _A_EECR
        PUBWEAK _A_EEDR
        PUBWEAK _A_EICRA
        PUBWEAK _A_EIFR
        PUBWEAK _A_EIMSK
        PUBWEAK _A_GPIOR0
        PUBWEAK _A_GPIOR1
        PUBWEAK _A_GPIOR2
        PUBWEAK _A_GTCCR
        PUBWEAK _A_ICR1
        PUBWEAK _A_MCUCR
        PUBWEAK _A_MCUSR
        PUBWEAK _A_OCR0A
        PUBWEAK _A_OCR0B
        PUBWEAK _A_OCR1A
        PUBWEAK _A_OCR1B
        PUBWEAK _A_OCR2A
        PUBWEAK _A_OCR2B
        PUBWEAK _A_OSCCAL
        PUBWEAK _A_PCICR
        PUBWEAK _A_PCIFR
        PUBWEAK _A_PCMSK0
        PUBWEAK _A_PCMSK1
        PUBWEAK _A_PCMSK2
        PUBWEAK _A_PINB
        PUBWEAK _A_PINC
        PUBWEAK _A_PIND
        PUBWEAK _A_PORTB
        PUBWEAK _A_PORTC
        PUBWEAK _A_PORTD
        PUBWEAK _A_PRR
        PUBWEAK _A_SMCR
        PUBWEAK _A_SP
        PUBWEAK _A_SPCR
        PUBWEAK _A_SPDR
        PUBWEAK _A_SPMCSR
        PUBWEAK _A_SPSR
        PUBWEAK _A_SREG
        PUBWEAK _A_TCCR0A
        PUBWEAK _A_TCCR0B
        PUBWEAK _A_TCCR1A
        PUBWEAK _A_TCCR1B
        PUBWEAK _A_TCCR1C
        PUBWEAK _A_TCCR2A
        PUBWEAK _A_TCCR2B
        PUBWEAK _A_TCNT0
        PUBWEAK _A_TCNT1
        PUBWEAK _A_TCNT2
        PUBWEAK _A_TIFR0
        PUBWEAK _A_TIFR1
        PUBWEAK _A_TIFR2
        PUBWEAK _A_TIMSK0
        PUBWEAK _A_TIMSK1
        PUBWEAK _A_TIMSK2
        PUBWEAK _A_TWAMR
        PUBWEAK _A_TWAR
        PUBWEAK _A_TWBR
        PUBWEAK _A_TWCR
        PUBWEAK _A_TWDR
        PUBWEAK _A_TWSR
        PUBWEAK _A_UBRR0
        PUBWEAK _A_UCSR0A
        PUBWEAK _A_UCSR0B
        PUBWEAK _A_UCSR0C
        PUBWEAK _A_UDR0
        PUBWEAK _A_WDTCSR
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR

`?<Name CModbus 1>` SYMBOL "CModbus"
??m_pui16HoldingRegisters SYMBOL "m_pui16HoldingRegisters", `?<Name CModbus 1>`
??m_pui16InputRegisters SYMBOL "m_pui16InputRegisters", `?<Name CModbus 1>`
??m_puiCoils        SYMBOL "m_puiCoils", `?<Name CModbus 1>`
??m_puiDiscreteInputs SYMBOL "m_puiDiscreteInputs", `?<Name CModbus 1>`
??m_puiRxBuffer     SYMBOL "m_puiRxBuffer", `?<Name CModbus 1>`
??m_puiTxBuffer     SYMBOL "m_puiTxBuffer", `?<Name CModbus 1>`
??m_uiCoilsNumber   SYMBOL "m_uiCoilsNumber", `?<Name CModbus 1>`
??m_uiDiscreteInputsNumber SYMBOL "m_uiDiscreteInputsNumber", `?<Name CModbus 1>`
??m_uiFlowControl   SYMBOL "m_uiFlowControl", `?<Name CModbus 1>`
??m_uiFunctionCode  SYMBOL "m_uiFunctionCode", `?<Name CModbus 1>`
??m_uiHoldingRegistersNumber SYMBOL "m_uiHoldingRegistersNumber", `?<Name CModbus 1>`
??m_uiInputRegistersNumber SYMBOL "m_uiInputRegistersNumber", `?<Name CModbus 1>`
??m_uiLastSystemTime SYMBOL "m_uiLastSystemTime", `?<Name CModbus 1>`
??m_uiMessageLength SYMBOL "m_uiMessageLength", `?<Name CModbus 1>`
??m_uiSlave         SYMBOL "m_uiSlave", `?<Name CModbus 1>`

        EXTERN ??ResponseBasis
        EXTERN ??Send
        EXTERN ??Tail

// D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Modbus\Modbus.cpp
//    1 //-----------------------------------------------------------------------------------------------------
//    2 //  Sourse      : FileName.cpp
//    3 //  Created     : 01.06.2022
//    4 //  Author      : Alexandr Volvenkin
//    5 //  email       : aav-36@mail.ru
//    6 //  GitHub      : https://github.com/AlexandrVolvenkin
//    7 //-----------------------------------------------------------------------------------------------------
//    8 
//    9 #include "Modbus.h"

        ASEGN ABSOLUTE:DATA:ROOT,0c6H
// union <unnamed> volatile __io _A_UDR0
_A_UDR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c4H
// union <unnamed> volatile __io _A_UBRR0
_A_UBRR0:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,0c2H
// union <unnamed> volatile __io _A_UCSR0C
_A_UCSR0C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c1H
// union <unnamed> volatile __io _A_UCSR0B
_A_UCSR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c0H
// union <unnamed> volatile __io _A_UCSR0A
_A_UCSR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bdH
// union <unnamed> volatile __io _A_TWAMR
_A_TWAMR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bcH
// union <unnamed> volatile __io _A_TWCR
_A_TWCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bbH
// union <unnamed> volatile __io _A_TWDR
_A_TWDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0baH
// union <unnamed> volatile __io _A_TWAR
_A_TWAR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b9H
// union <unnamed> volatile __io _A_TWSR
_A_TWSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b8H
// union <unnamed> volatile __io _A_TWBR
_A_TWBR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b6H
// union <unnamed> volatile __io _A_ASSR
_A_ASSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b4H
// union <unnamed> volatile __io _A_OCR2B
_A_OCR2B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b3H
// union <unnamed> volatile __io _A_OCR2A
_A_OCR2A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b2H
// union <unnamed> volatile __io _A_TCNT2
_A_TCNT2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b1H
// union <unnamed> volatile __io _A_TCCR2B
_A_TCCR2B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b0H
// union <unnamed> volatile __io _A_TCCR2A
_A_TCCR2A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,08aH
// union <unnamed> volatile __io _A_OCR1B
_A_OCR1B:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,088H
// union <unnamed> volatile __io _A_OCR1A
_A_OCR1A:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,086H
// union <unnamed> volatile __io _A_ICR1
_A_ICR1:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,084H
// union <unnamed> volatile __io _A_TCNT1
_A_TCNT1:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,082H
// union <unnamed> volatile __io _A_TCCR1C
_A_TCCR1C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,081H
// union <unnamed> volatile __io _A_TCCR1B
_A_TCCR1B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,080H
// union <unnamed> volatile __io _A_TCCR1A
_A_TCCR1A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07fH
// union <unnamed> volatile __io _A_DIDR1
_A_DIDR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07eH
// union <unnamed> volatile __io _A_DIDR0
_A_DIDR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07cH
// union <unnamed> volatile __io _A_ADMUX
_A_ADMUX:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07bH
// union <unnamed> volatile __io _A_ADCSRB
_A_ADCSRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07aH
// union <unnamed> volatile __io _A_ADCSRA
_A_ADCSRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,078H
// union <unnamed> volatile __io _A_ADC
_A_ADC:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,070H
// union <unnamed> volatile __io _A_TIMSK2
_A_TIMSK2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06fH
// union <unnamed> volatile __io _A_TIMSK1
_A_TIMSK1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06eH
// union <unnamed> volatile __io _A_TIMSK0
_A_TIMSK0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06dH
// union <unnamed> volatile __io _A_PCMSK2
_A_PCMSK2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06cH
// union <unnamed> volatile __io _A_PCMSK1
_A_PCMSK1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06bH
// union <unnamed> volatile __io _A_PCMSK0
_A_PCMSK0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,069H
// union <unnamed> volatile __io _A_EICRA
_A_EICRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,068H
// union <unnamed> volatile __io _A_PCICR
_A_PCICR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,066H
// union <unnamed> volatile __io _A_OSCCAL
_A_OSCCAL:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,064H
// union <unnamed> volatile __io _A_PRR
_A_PRR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,061H
// union <unnamed> volatile __io _A_CLKPR
_A_CLKPR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,060H
// union <unnamed> volatile __io _A_WDTCSR
_A_WDTCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05fH
// union <unnamed> volatile __io _A_SREG
_A_SREG:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05dH
// union <unnamed> volatile __io _A_SP
_A_SP:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,057H
// union <unnamed> volatile __io _A_SPMCSR
_A_SPMCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,055H
// union <unnamed> volatile __io _A_MCUCR
_A_MCUCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,054H
// union <unnamed> volatile __io _A_MCUSR
_A_MCUSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,053H
// union <unnamed> volatile __io _A_SMCR
_A_SMCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,050H
// union <unnamed> volatile __io _A_ACSR
_A_ACSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04eH
// union <unnamed> volatile __io _A_SPDR
_A_SPDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04dH
// union <unnamed> volatile __io _A_SPSR
_A_SPSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04cH
// union <unnamed> volatile __io _A_SPCR
_A_SPCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04bH
// union <unnamed> volatile __io _A_GPIOR2
_A_GPIOR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04aH
// union <unnamed> volatile __io _A_GPIOR1
_A_GPIOR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,048H
// union <unnamed> volatile __io _A_OCR0B
_A_OCR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,047H
// union <unnamed> volatile __io _A_OCR0A
_A_OCR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,046H
// union <unnamed> volatile __io _A_TCNT0
_A_TCNT0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,045H
// union <unnamed> volatile __io _A_TCCR0B
_A_TCCR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,044H
// union <unnamed> volatile __io _A_TCCR0A
_A_TCCR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,043H
// union <unnamed> volatile __io _A_GTCCR
_A_GTCCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,041H
// union <unnamed> volatile __io _A_EEAR
_A_EEAR:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,040H
// union <unnamed> volatile __io _A_EEDR
_A_EEDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03fH
// union <unnamed> volatile __io _A_EECR
_A_EECR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03eH
// union <unnamed> volatile __io _A_GPIOR0
_A_GPIOR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03dH
// union <unnamed> volatile __io _A_EIMSK
_A_EIMSK:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03cH
// union <unnamed> volatile __io _A_EIFR
_A_EIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03bH
// union <unnamed> volatile __io _A_PCIFR
_A_PCIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,037H
// union <unnamed> volatile __io _A_TIFR2
_A_TIFR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,036H
// union <unnamed> volatile __io _A_TIFR1
_A_TIFR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,035H
// union <unnamed> volatile __io _A_TIFR0
_A_TIFR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02bH
// union <unnamed> volatile __io _A_PORTD
_A_PORTD:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02aH
// union <unnamed> volatile __io _A_DDRD
_A_DDRD:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,029H
// union <unnamed> volatile __io _A_PIND
_A_PIND:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,028H
// union <unnamed> volatile __io _A_PORTC
_A_PORTC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,027H
// union <unnamed> volatile __io _A_DDRC
_A_DDRC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,026H
// union <unnamed> volatile __io _A_PINC
_A_PINC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,025H
// union <unnamed> volatile __io _A_PORTB
_A_PORTB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,024H
// union <unnamed> volatile __io _A_DDRB
_A_DDRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,023H
// union <unnamed> volatile __io _A_PINB
_A_PINB:
        DS8 1
//   10 #include "ModbusRTU.h"
//   11 #include "Platform.h"
//   12 
//   13 

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   14 uint8_t CModbus::m_uiSlave;
??m_uiSlave:
        DS8 1

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   15 uint8_t CModbus::m_uiFunctionCode;
??m_uiFunctionCode:
        DS8 1

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   16 uint8_t CModbus::m_uiFlowControl;
??m_uiFlowControl:
        DS8 1
//   17 //    CSocket* pxSocket;

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   18 uint16_t CModbus::m_uiLastSystemTime;
??m_uiLastSystemTime:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   19 uint16_t CModbus::m_uiMessageLength;
??m_uiMessageLength:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   20 uint8_t *CModbus::m_puiRxBuffer;
??m_puiRxBuffer:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   21 uint8_t *CModbus::m_puiTxBuffer;
??m_puiTxBuffer:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   22 uint8_t *CModbus::m_puiCoils;
??m_puiCoils:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   23 uint8_t *CModbus::m_puiDiscreteInputs;
??m_puiDiscreteInputs:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   24 uint16_t *CModbus::m_pui16HoldingRegisters;
??m_pui16HoldingRegisters:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   25 uint16_t *CModbus::m_pui16InputRegisters;
??m_pui16InputRegisters:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   26 uint16_t CModbus::m_uiCoilsNumber;
??m_uiCoilsNumber:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   27 uint16_t CModbus::m_uiDiscreteInputsNumber;
??m_uiDiscreteInputsNumber:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   28 uint16_t CModbus::m_uiHoldingRegistersNumber;
??m_uiHoldingRegistersNumber:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   29 uint16_t CModbus::m_uiInputRegistersNumber;
??m_uiInputRegistersNumber:
        DS8 2
//   30 
//   31 ////-----------------------------------------------------------------------------------------------------
//   32 //CModbus::CModbus()
//   33 //{
//   34 //    //ctor
//   35 //}
//   36 //
//   37 //////-----------------------------------------------------------------------------------------------------
//   38 ////CModbus::CModbus(CUart* pxDevice,
//   39 ////                 uint32_t uiBaudRate,
//   40 ////                 char cParity,
//   41 ////                 uint8_t uiDataBit,
//   42 ////                 uint8_t uiStopBit,
//   43 ////                 uint8_t *puiRxBuffer,
//   44 ////                 uint8_t *puiTxBuffer) :
//   45 ////    pxDevice(pxDevice),
//   46 ////    uiBaudRate(uiBaudRate),
//   47 ////    cParity(cParity),
//   48 ////    uiDataBit(uiDataBit),
//   49 ////    uiStopBit(uiStopBit),
//   50 ////    m_puiRxBuffer(puiRxBuffer),
//   51 ////    m_puiTxBuffer(puiTxBuffer)
//   52 ////{
//   53 ////    m_uiFlowControl = MODBUS_IDDLE;
//   54 ////}
//   55 //
//   56 ////-----------------------------------------------------------------------------------------------------
//   57 //CModbus::~CModbus()
//   58 //{
//   59 //
//   60 //}
//   61 
//   62 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   63 void CModbus::SlaveSet(uint8_t uiSlave)
??SlaveSet:
//   64 {
//   65     m_uiSlave = uiSlave;
        STS     ??m_uiSlave, R16
//   66 }
        RET
//   67 
//   68 ////-----------------------------------------------------------------------------------------------------
//   69 //int8_t CModbus::MessengerIsReady(void)
//   70 //{
//   71 //    if (m_uiFlowControl == IDDLE)
//   72 //    {
//   73 //        return 1;
//   74 //    }
//   75 //    else
//   76 //    {
//   77 //        return 0;
//   78 //    }
//   79 //}
//   80 
//   81 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   82 int16_t CModbus::SendMessage(uint8_t *puiMessage, uint16_t uiLength)
??SendMessage:
//   83 {
        RCALL   ?PROLOGUE4_L09
        MOVW    R27:R26, R17:R16
        MOVW    R25:R24, R19:R18
//   84     uiLength = CModbusRTU::Tail(puiMessage, uiLength);
        MOVW    R19:R18, R25:R24
        MOVW    R17:R16, R27:R26
        RCALL   ??Tail
        MOVW    R25:R24, R17:R16
//   85     return CModbusRTU::Send(puiMessage, uiLength);
        MOVW    R19:R18, R25:R24
        MOVW    R17:R16, R27:R26
        RCALL   ??Send
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09
//   86 }
//   87 
//   88 //-----------------------------------------------------------------------------------------------------
//   89 /* Build the exception response */

        RSEG CODE:CODE:NOROOT(1)
//   90 int16_t CModbus::ResponseException(uint8_t uiSlave, uint8_t uiFunctionCode, uint8_t uiExceptionCode, uint8_t *puiResponse)
??ResponseException:
//   91 {
        RCALL   ?PROLOGUE7_L09
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        MOV     R4, R16
        MOV     R5, R17
        MOV     R6, R18
        MOVW    R25:R24, R21:R20
//   92     int16_t uiLength;
//   93 
//   94     uiLength = CModbusRTU::ResponseBasis(uiSlave, (uiFunctionCode | 0x80), puiResponse);
        MOVW    R19:R18, R25:R24
        MOV     R17, R5
        ORI     R17, 0x80
        MOV     R16, R4
        RCALL   ??ResponseBasis
        MOVW    R27:R26, R17:R16
//   95     /* Positive exception code */
//   96     puiResponse[uiLength++] = uiExceptionCode;
        MOVW    R31:R30, R25:R24
        ADD     R30, R26
        ADC     R31, R27
        ST      Z, R6
        ADIW    R27:R26, 1
//   97 
//   98     return uiLength;
        MOVW    R17:R16, R27:R26
        LDI     R30, 7
        RJMP    ?EPILOGUE_B7_L09
//   99 }
//  100 
//  101 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  102 uint8_t CModbus::ResponseIsReceived(void)
??ResponseIsReceived:
//  103 {
//  104     if (m_uiFlowControl  == IDDLE)
        LDS     R16, ??m_uiFlowControl
        TST     R16
        BRNE    ??ResponseIsReceived_1
//  105     {
//  106         return 1;
        LDI     R16, 1
        RET
//  107     }
//  108     else
//  109     {
//  110         return 0;
??ResponseIsReceived_1:
        LDI     R16, 0
        RET
//  111     }
//  112 };
//  113 
//  114 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  115 int16_t CModbus::ByteToBitPack(uint16_t uiAddress,
??ByteToBitPack:
//  116                                uint16_t uiNumberB,
//  117                                uint8_t *m_puiCoils,
//  118                                uint8_t *puiResponse,
//  119                                uint16_t uiLength)
//  120 {
        RCALL   ?PROLOGUE5_L09
        REQUIRE ?Register_R4_is_cg_reg
        MOVW    R1:R0, R17:R16
        MOVW    R3:R2, R21:R20
        LDD     R24, Y+5
        LDD     R25, Y+6
//  121     uint8_t uiData = 0;
        LDI     R21, 0
//  122     uint8_t uiShift = 0;
        CLR     R4
//  123     for (uint16_t i = 0; i < uiNumberB; i++)
        LDI     R26, 0
        LDI     R27, 0
??ByteToBitPack_1:
        CP      R26, R18
        CPC     R27, R19
        BRCC    ??ByteToBitPack_2
//  124     {
//  125         if (m_puiCoils[uiAddress++])
        MOVW    R17:R16, R1:R0
        MOVW    R31:R30, R17:R16
        ADIW    R31:R30, 1
        MOVW    R1:R0, R31:R30
        MOVW    R31:R30, R3:R2
        ADD     R30, R16
        ADC     R31, R17
        LD      R16, Z
        TST     R16
        BREQ    ??ByteToBitPack_3
//  126         {
//  127             uiData |= (1 << uiShift);
        LDI     R16, 1
        LDI     R17, 0
        MOV     R20, R4
        RCALL   ?S_SHL_L02
        OR      R21, R16
//  128         }
//  129         // Byte is full?
//  130         if (uiShift == 7)
??ByteToBitPack_3:
        LDI     R16, 7
        CP      R4, R16
        BRNE    ??ByteToBitPack_4
//  131         {
//  132             puiResponse[uiLength++] = uiData;
        MOVW    R31:R30, R23:R22
        ADD     R30, R24
        ADC     R31, R25
        ST      Z, R21
        ADIW    R25:R24, 1
//  133             uiData = 0;
        LDI     R21, 0
//  134             uiShift = 0;
        CLR     R4
        RJMP    ??ByteToBitPack_5
//  135         }
//  136         else
//  137         {
//  138             uiShift++;
??ByteToBitPack_4:
        INC     R4
//  139         }
//  140     }
??ByteToBitPack_5:
        ADIW    R27:R26, 1
        RJMP    ??ByteToBitPack_1
//  141 
//  142     if (uiShift != 0)
??ByteToBitPack_2:
        TST     R4
        BREQ    ??ByteToBitPack_6
//  143     {
//  144         puiResponse[uiLength++] = uiData;
        MOVW    R31:R30, R23:R22
        ADD     R30, R24
        ADC     R31, R25
        ST      Z, R21
        ADIW    R25:R24, 1
//  145     }
//  146 
//  147     return uiLength;
??ByteToBitPack_6:
        MOVW    R17:R16, R25:R24
        LDI     R30, 7
        RJMP    ?EPILOGUE_B5_L09
//  148 }
//  149 
//  150 ////-----------------------------------------------------------------------------------------------------
//  151 //int16_t CModbus::ReadCoils(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  152 //{
//  153 //    uint16_t uiOffset = HEADER_LENGTH;
//  154 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  155 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  156 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  157 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  158 //
//  159 //    uint16_t uiNumberB = ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  160 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  161 //
//  162 //    if (uiNumberB < 1 || MODBUS_MAX_READ_BITS < uiNumberB)
//  163 //    {
//  164 //        uiLength = ResponseException(uiSlave,
//  165 //                                     uiFunctionCode,
//  166 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  167 //                                     puiResponse);
//  168 //    }
//  169 //    else if ((uiAddress + uiNumberB) > m_uiCoilsNumber)
//  170 //    {
//  171 //        uiLength = ResponseException(uiSlave,
//  172 //                                     uiFunctionCode,
//  173 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  174 //                                     puiResponse);
//  175 //    }
//  176 //    else
//  177 //    {
//  178 //        uiLength = CModbusRTU::ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  179 //
//  180 //        if (uiNumberB % 8)
//  181 //        {
//  182 //            puiResponse[uiLength++] = ((uiNumberB / 8) + 1);
//  183 //        }
//  184 //        else
//  185 //        {
//  186 //            puiResponse[uiLength++] = (uiNumberB / 8);
//  187 //        }
//  188 //        uiLength = ByteToBitPack(uiAddress,
//  189 //                                 uiNumberB,
//  190 //                                 m_puiCoils,
//  191 //                                 puiResponse,
//  192 //                                 uiLength);
//  193 //    }
//  194 //    return uiLength;
//  195 //}
//  196 
//  197 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  198 int16_t CModbus::ReadDiscreteInputs(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
??ReadDiscreteInputs:
//  199 {
        RCALL   ?PROLOGUE14_L09
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R7_is_cg_reg
        REQUIRE ?Register_R8_is_cg_reg
        REQUIRE ?Register_R9_is_cg_reg
        REQUIRE ?Register_R10_is_cg_reg
        REQUIRE ?Register_R11_is_cg_reg
        REQUIRE ?Register_R12_is_cg_reg
        REQUIRE ?Register_R13_is_cg_reg
        MOVW    R7:R6, R17:R16
        MOVW    R5:R4, R19:R18
        MOVW    R25:R24, R21:R20
//  200     uint16_t uiOffset = HEADER_LENGTH;
        CLR     R11
        CLR     R10
        INC     R10
//  201     int8_t uiSlave = puiRequest[uiOffset - 1];
        MOVW    R31:R30, R7:R6
        ADD     R30, R10
        ADC     R31, R11
        SBIW    R31:R30, 1
        LD      R13, Z
//  202     int8_t uiFunctionCode = puiRequest[uiOffset];
        MOVW    R31:R30, R7:R6
        ADD     R30, R10
        ADC     R31, R11
        LD      R12, Z
//  203     uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  204                           (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
        MOVW    R31:R30, R7:R6
        ADD     R30, R10
        ADC     R31, R11
        LDD     R9, Z+1
        CLR     R8
        MOVW    R31:R30, R7:R6
        ADD     R30, R10
        ADC     R31, R11
        LDD     R16, Z+2
        LDI     R17, 0
        OR      R8, R16
        OR      R9, R17
//  205 
//  206     uint16_t uiNumberB = ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  207                           (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
        MOVW    R31:R30, R7:R6
        ADD     R30, R10
        ADC     R31, R11
        LDD     R27, Z+3
        LDI     R26, 0
        MOVW    R31:R30, R7:R6
        ADD     R30, R10
        ADC     R31, R11
        LDD     R16, Z+4
        LDI     R17, 0
        OR      R26, R16
        OR      R27, R17
//  208 
//  209     if (uiNumberB < 1 || MODBUS_MAX_READ_BITS < uiNumberB)
        MOV     R16, R26
        OR      R16, R27
        BREQ    ??ReadDiscreteInputs_1
        CPI     R26, 209
        LDI     R16, 7
        CPC     R27, R16
        BRCS    ??ReadDiscreteInputs_2
//  210     {
//  211         uiLength = ResponseException(uiSlave,
//  212                                      uiFunctionCode,
//  213                                      MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  214                                      puiResponse);
??ReadDiscreteInputs_1:
        MOVW    R21:R20, R5:R4
        LDI     R18, 3
        MOV     R17, R12
        MOV     R16, R13
        RCALL   ??ResponseException
        MOVW    R25:R24, R17:R16
        RJMP    ??ReadDiscreteInputs_3
//  215     }
//  216     else if ((uiAddress + uiNumberB) > m_uiDiscreteInputsNumber)
??ReadDiscreteInputs_2:
        LDI     R30, LOW(??m_uiDiscreteInputsNumber)
        LDI     R31, (??m_uiDiscreteInputsNumber) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        MOVW    R19:R18, R9:R8
        ADD     R18, R26
        ADC     R19, R27
        CP      R16, R18
        CPC     R17, R19
        BRCC    ??ReadDiscreteInputs_4
//  217     {
//  218         uiLength = ResponseException(uiSlave,
//  219                                      uiFunctionCode,
//  220                                      MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  221                                      puiResponse);
        MOVW    R21:R20, R5:R4
        LDI     R18, 2
        MOV     R17, R12
        MOV     R16, R13
        RCALL   ??ResponseException
        MOVW    R25:R24, R17:R16
        RJMP    ??ReadDiscreteInputs_3
//  222     }
//  223     else
//  224     {
//  225         uiLength = CModbusRTU::ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
??ReadDiscreteInputs_4:
        MOVW    R19:R18, R5:R4
        MOV     R17, R12
        MOV     R16, R13
        RCALL   ??ResponseBasis
        MOVW    R25:R24, R17:R16
//  226 
//  227         if (uiNumberB % 8)
        MOV     R16, R26
        ANDI    R16, 0x07
        TST     R16
        BREQ    ??ReadDiscreteInputs_5
//  228         {
//  229             puiResponse[uiLength++] = ((uiNumberB / 8) + 1);
        LDI     R20, 3
        MOVW    R17:R16, R27:R26
        RCALL   ?US_SHR_L02
        INC     R16
        MOVW    R31:R30, R5:R4
        ADD     R30, R24
        ADC     R31, R25
        ST      Z, R16
        ADIW    R25:R24, 1
        RJMP    ??ReadDiscreteInputs_6
//  230         }
//  231         else
//  232         {
//  233             puiResponse[uiLength++] = (uiNumberB / 8);
??ReadDiscreteInputs_5:
        LDI     R20, 3
        MOVW    R17:R16, R27:R26
        RCALL   ?US_SHR_L02
        MOVW    R31:R30, R5:R4
        ADD     R30, R24
        ADC     R31, R25
        ST      Z, R16
        ADIW    R25:R24, 1
//  234         }
//  235         uiLength = ByteToBitPack(uiAddress,
//  236                                  uiNumberB,
//  237                                  m_puiDiscreteInputs,
//  238                                  puiResponse,
//  239                                  uiLength);
??ReadDiscreteInputs_6:
        ST      -Y, R25
        ST      -Y, R24
        MOVW    R23:R22, R5:R4
        LDI     R30, LOW(??m_puiDiscreteInputs)
        LDI     R31, (??m_puiDiscreteInputs) >> 8
        LD      R20, Z
        LDD     R21, Z+1
        MOVW    R19:R18, R27:R26
        MOVW    R17:R16, R9:R8
        RCALL   ??ByteToBitPack
        MOVW    R25:R24, R17:R16
//  240     }
//  241     return uiLength;
??ReadDiscreteInputs_3:
        MOVW    R17:R16, R25:R24
        LDI     R30, 14
        RJMP    ?EPILOGUE_B14_L09
//  242 }
//  243 
//  244 ////-----------------------------------------------------------------------------------------------------
//  245 //int16_t CModbus::ReadHoldingRegisters(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  246 //{
//  247 //    uint16_t uiOffset = HEADER_LENGTH;
//  248 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  249 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  250 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  251 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  252 //
//  253 //    uint16_t uiNumberB = ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  254 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  255 //
//  256 //    if (uiNumberB < 1 || MODBUS_MAX_READ_REGISTERS < uiNumberB)
//  257 //    {
//  258 //        uiLength = ResponseException(uiSlave,
//  259 //                                     uiFunctionCode,
//  260 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  261 //                                     puiResponse);
//  262 //    }
//  263 //    else if ((uiAddress + uiNumberB) > m_uiHoldingRegistersNumber)
//  264 //    {
//  265 //        uiLength = ResponseException(uiSlave,
//  266 //                                     uiFunctionCode,
//  267 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  268 //                                     puiResponse);
//  269 //    }
//  270 //    else
//  271 //    {
//  272 //        uiLength = ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  273 //        puiResponse[uiLength++] = (uiNumberB << 1);
//  274 //        for (uint16_t i = 0; i < uiNumberB; i++)
//  275 //        {
//  276 //            puiResponse[uiLength++] = (static_cast<uint16_t>(m_pui16HoldingRegisters[uiAddress]) >> 8);
//  277 //            puiResponse[uiLength++] = (static_cast<uint16_t>(m_pui16HoldingRegisters[uiAddress++]) & 0x00FF);
//  278 //        }
//  279 //    }
//  280 //    return uiLength;
//  281 //}
//  282 //
//  283 ////-----------------------------------------------------------------------------------------------------
//  284 //int16_t CModbus::ReadInputRegisters(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  285 //{
//  286 //    uint16_t uiOffset = HEADER_LENGTH;
//  287 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  288 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  289 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  290 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  291 //
//  292 //    uint16_t uiNumberB = ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  293 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  294 //
//  295 //    if (uiNumberB < 1 || MODBUS_MAX_READ_REGISTERS < uiNumberB)
//  296 //    {
//  297 //        uiLength = ResponseException(uiSlave,
//  298 //                                     uiFunctionCode,
//  299 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  300 //                                     puiResponse);
//  301 //    }
//  302 //    else if ((uiAddress + uiNumberB) > m_uiInputRegistersNumber)
//  303 //    {
//  304 //        uiLength = ResponseException(uiSlave,
//  305 //                                     uiFunctionCode,
//  306 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  307 //                                     puiResponse);
//  308 //    }
//  309 //    else
//  310 //    {
//  311 //        uiLength = ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  312 //        puiResponse[uiLength++] = (uiNumberB << 1);
//  313 //        for (uint16_t i = 0; i < uiNumberB; i++)
//  314 //        {
//  315 //            puiResponse[uiLength++] = (static_cast<uint16_t>(m_pui16InputRegisters[uiAddress]) >> 8);
//  316 //            puiResponse[uiLength++] = (static_cast<uint16_t>(m_pui16InputRegisters[uiAddress++]) & 0x00FF);
//  317 //        }
//  318 //    }
//  319 //    return uiLength;
//  320 //}
//  321 
//  322 ////-----------------------------------------------------------------------------------------------------
//  323 //int16_t CModbus::WriteSingleCoil(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  324 //{
//  325 //    uint16_t uiOffset = HEADER_LENGTH;
//  326 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  327 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  328 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  329 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  330 //
//  331 //    if (uiAddress >= m_uiCoilsNumber)
//  332 //    {
//  333 //        uiLength = ResponseException(uiSlave,
//  334 //                                     uiFunctionCode,
//  335 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  336 //                                     puiResponse);
//  337 //    }
//  338 //    else
//  339 //    {
//  340 //        uint16_t uiData = ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  341 //                           (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  342 //
//  343 //        if (uiData == 0xFF00 || uiData == 0x0)
//  344 //        {
//  345 //            if (uiData)
//  346 //            {
//  347 //                m_puiCoils[uiAddress] = ON;
//  348 //            }
//  349 //            else
//  350 //            {
//  351 //                m_puiCoils[uiAddress] = OFF;
//  352 //            }
//  353 //            memcpy(puiResponse, puiRequest, uiLength);
//  354 //        }
//  355 //        else
//  356 //        {
//  357 //            uiLength = ResponseException(uiSlave,
//  358 //                                         uiFunctionCode,
//  359 //                                         MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  360 //                                         puiResponse);
//  361 //        }
//  362 //    }
//  363 //    return uiLength;
//  364 //}
//  365 //
//  366 ////-----------------------------------------------------------------------------------------------------
//  367 //int16_t CModbus::WriteSingleRegister(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  368 //{
//  369 //    uint16_t uiOffset = HEADER_LENGTH;
//  370 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  371 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  372 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  373 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  374 //
//  375 //    if (uiAddress >= m_uiHoldingRegistersNumber)
//  376 //    {
//  377 //        uiLength = ResponseException(uiSlave,
//  378 //                                     uiFunctionCode,
//  379 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  380 //                                     puiResponse);
//  381 //    }
//  382 //    else
//  383 //    {
//  384 //        m_pui16HoldingRegisters[uiAddress] =
//  385 //            ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  386 //             (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  387 //        memcpy(puiResponse, puiRequest, uiLength);
//  388 //    }
//  389 //    return uiLength;
//  390 //}
//  391 //
//  392 ////-----------------------------------------------------------------------------------------------------
//  393 //int16_t CModbus::WriteMultipleCoils(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  394 //{
//  395 //    uint16_t uiOffset = HEADER_LENGTH;
//  396 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  397 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  398 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  399 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  400 //
//  401 //    uint16_t uiNumberB = ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  402 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  403 //
//  404 //    if (uiNumberB < 1 || MODBUS_MAX_WRITE_BITS < uiNumberB)
//  405 //    {
//  406 //        uiLength = ResponseException(uiSlave,
//  407 //                                     uiFunctionCode,
//  408 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  409 //                                     puiResponse);
//  410 //    }
//  411 //    else if ((uiAddress + uiNumberB) > m_uiCoilsNumber)
//  412 //    {
//  413 //        uiLength = ResponseException(uiSlave,
//  414 //                                     uiFunctionCode,
//  415 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  416 //                                     puiResponse);
//  417 //    }
//  418 //    else
//  419 //    {
//  420 //
//  421 //        SetBytesFromBits(m_puiCoils, uiAddress, uiNumberB, &puiRequest[uiOffset + 6]);
//  422 //        uiLength = ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  423 //        /* 4 to copy the bit address (2) and the quantity of bits */
//  424 //        memcpy(puiResponse + uiLength, puiRequest + uiLength, 4);
//  425 //        uiLength += 4;
//  426 //    }
//  427 //    return uiLength;
//  428 //}
//  429 //
//  430 ////-----------------------------------------------------------------------------------------------------
//  431 //int16_t CModbus::WriteMultipleRegisters(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  432 //{
//  433 //    uint16_t uiOffset = HEADER_LENGTH;
//  434 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  435 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  436 //    uint16_t uiAddress = ((static_cast<uint16_t>(puiRequest[uiOffset + 1]) << 8) |
//  437 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 2])));
//  438 //
//  439 //    uint16_t uiNumberB = ((static_cast<uint16_t>(puiRequest[uiOffset + 3]) << 8) |
//  440 //                          (static_cast<uint16_t>(puiRequest[uiOffset + 4])));
//  441 //
//  442 //    if (uiNumberB < 1 || MODBUS_MAX_WRITE_REGISTERS < uiNumberB)
//  443 //    {
//  444 //        uiLength = ResponseException(uiSlave,
//  445 //                                     uiFunctionCode,
//  446 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  447 //                                     puiResponse);
//  448 //    }
//  449 //    else if ((uiAddress + uiNumberB) > m_uiHoldingRegistersNumber)
//  450 //    {
//  451 //        uiLength = ResponseException(uiSlave,
//  452 //                                     uiFunctionCode,
//  453 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  454 //                                     puiResponse);
//  455 //    }
//  456 //    else
//  457 //    {
//  458 //        for (uint16_t i = 0; i < uiNumberB; i++)
//  459 //        {
//  460 //            m_pui16HoldingRegisters[uiAddress++] = ((static_cast<uint16_t>(puiRequest[uiOffset + 6]) << 8) |
//  461 //                                                    (static_cast<uint16_t>(puiRequest[uiOffset + 6 + 1])));
//  462 //            uiOffset += 2;
//  463 //        }
//  464 //
//  465 //        uiLength = ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  466 //        /* 4 to copy the bit address (2) and the quantity of bits */
//  467 //        memcpy(puiResponse + uiLength, puiRequest + uiLength, 4);
//  468 //        uiLength += 4;
//  469 //
//  470 //    }
//  471 //    return uiLength;
//  472 //}
//  473 
//  474 ////-----------------------------------------------------------------------------------------------------
//  475 //int16_t CModbus::ReadExceptionStatus(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  476 //{
//  477 ////    errno = ENOPROTOOPT;
//  478 //    return -1;
//  479 //}
//  480 //
//  481 ////-----------------------------------------------------------------------------------------------------
//  482 //int16_t CModbus::WriteAndReadRegisters(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  483 //{
//  484 //}
//  485 //
//  486 ////-----------------------------------------------------------------------------------------------------
//  487 //int16_t CModbus::ReportSlaveID(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  488 //{
//  489 //    uint16_t uiOffset = HEADER_LENGTH;
//  490 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  491 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  492 //
//  493 //    uiLength = ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  494 //    puiResponse[uiLength++] = 3;			// Число байт данных
//  495 //    puiResponse[uiLength++] = 32;			// Количество окон сигнализации
//  496 //    puiResponse[uiLength++] = 7;			// Код модификации
//  497 //    puiResponse[uiLength++] = 50;			// Код устройства
//  498 //
//  499 //    return uiLength;
//  500 //}
//  501 
//  502 ////-----------------------------------------------------------------------------------------------------
//  503 //int16_t CModbus::Programming(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  504 //{
//  505 //// Функция 0x46 "программирование". Описание протокола обмена:
//  506 //// Buff[0] - адрес Slave.
//  507 //// Buff[1] - код функции.
//  508 //// Buff[2] - количество байт в запросе команды старший байт.
//  509 //// Buff[3] - количество байт в запросе команды младший байт.
//  510 //// Buff[4] - код операции(0 - запрос версии ПО, 1 - чтение блокаБД, 2 - запись блокаБД).
//  511 //// Buff[5] - номер блока БД.
//  512 //
//  513 //    // Смещения в принятом буфере.
//  514 //    enum
//  515 //    {
//  516 //        REQUEST_LENGTH = 2,
//  517 //        REQUEST_COMMAND = 3,
//  518 //        BLOCK_NUMBER = 4,
//  519 //        DATA_BEGIN = 5,
//  520 //    };
//  521 //
//  522 //    uint16_t uiOffset = HEADER_LENGTH;
//  523 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  524 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  525 //
//  526 //    uint16_t uiNumberB = (static_cast<uint16_t>(puiRequest[uiOffset + REQUEST_LENGTH]));
//  527 //
//  528 //    if (uiNumberB != (uiLength - 6))
//  529 //    {
//  530 //        uiLength = ResponseException(uiSlave,
//  531 //                                     uiFunctionCode,
//  532 //                                     MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  533 //                                     puiResponse);
//  534 //    }
//  535 //    else
//  536 //    {
//  537 //        uint8_t uiBlockNumber;
//  538 //        uiLength = ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  539 //        // Какой код операции?
//  540 //        switch(puiRequest[uiOffset + REQUEST_COMMAND])
//  541 //        {
//  542 //        case 0x00:
//  543 //            // Получение версии ПО.
//  544 //            puiResponse[uiLength++] = 0;
//  545 //            puiResponse[uiLength++] = 4;
//  546 //            puiResponse[uiLength++] = puiRequest[uiOffset + REQUEST_COMMAND];
//  547 //            puiResponse[uiLength++] = 1; // 1.7.01
//  548 //            puiResponse[uiLength++] = 7;
//  549 //            puiResponse[uiLength++] = 0x01;
//  550 //            break;
//  551 //
//  552 //        case 0x01:
//  553 //            // Чтение блока БД.
//  554 //            uiBlockNumber = puiRequest[uiOffset + BLOCK_NUMBER];
//  555 //            // Блок не существует?
//  556 //            if (uiBlockNumber > CDataBase::BLOCKS_QUANTITY)
//  557 //            {
//  558 //                uiLength = ResponseException(uiSlave,
//  559 //                                             uiFunctionCode,
//  560 //                                             MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  561 //                                             puiResponse);
//  562 //            }
//  563 //            else
//  564 //            {
//  565 //                // Прочитаем блок БД.
//  566 //                uint16_t uiLengthLocal = CDataBase::Read(&puiResponse[uiOffset + DATA_BEGIN], uiBlockNumber);
//  567 //                puiResponse[uiLength++] = 0;
//  568 //                puiResponse[uiLength++] = uiLengthLocal;
//  569 //                puiResponse[uiLength++] = puiRequest[uiOffset + REQUEST_COMMAND];
//  570 //                puiResponse[uiLength++] = uiBlockNumber;
//  571 //                uiLength += uiLengthLocal;
//  572 //            }
//  573 //            break;
//  574 //
//  575 //
//  576 //        case 0x02:
//  577 //            // Запись блока БД.
//  578 //            uiBlockNumber = puiRequest[uiOffset + BLOCK_NUMBER];
//  579 //            // Блок не существует?
//  580 //            if (uiBlockNumber > CDataBase::BLOCKS_QUANTITY)
//  581 //            {
//  582 //                uiLength = ResponseException(uiSlave,
//  583 //                                             uiFunctionCode,
//  584 //                                             MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
//  585 //                                             puiResponse);
//  586 //            }
//  587 //            // Размер блока не соответствует?
//  588 //            else if (puiRequest[uiOffset + REQUEST_LENGTH] != CDataBase::m_DStruct[uiBlockNumber].Size)
//  589 //            {
//  590 //                uiLength = ResponseException(uiSlave,
//  591 //                                             uiFunctionCode,
//  592 //                                             MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
//  593 //                                             puiResponse);
//  594 //            }
//  595 //            else
//  596 //            {
//  597 //                // Сохраним блок БД.
//  598 //                // Успешно?
//  599 //                if (CDataBase::Write(&puiRequest[uiOffset + DATA_BEGIN], uiBlockNumber))
//  600 //                {
//  601 //                    CDataBase::SetStatus(1);
//  602 //                }
//  603 //                else
//  604 //                {
//  605 //                    CDataBase::SetStatus(0);
//  606 //                }
//  607 //            }
//  608 //            break;
//  609 //
//  610 //
//  611 //        case 0x03:
//  612 //            if(!(CDataBase::GetStatus()))
//  613 //            {
//  614 //                uiLength = ResponseException(uiSlave,
//  615 //                                             uiFunctionCode,
//  616 //                                             MODBUS_EXCEPTION_ILLEGAL_FUNCTION,
//  617 //                                             puiResponse);
//  618 //            }
//  619 //            break;
//  620 //
//  621 //        default:
//  622 //            uiLength = ResponseException(uiSlave,
//  623 //                                         uiFunctionCode,
//  624 //                                         MODBUS_EXCEPTION_ILLEGAL_FUNCTION,
//  625 //                                         puiResponse);
//  626 //            break;
//  627 //        };
//  628 //    }
//  629 //
//  630 //    return uiLength;
//  631 //}
//  632 //
//  633 ////-----------------------------------------------------------------------------------------------------
//  634 //int16_t CModbus::PollProgramming(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  635 //
//  636 //{
//  637 //    uint16_t uiOffset = HEADER_LENGTH;
//  638 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  639 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  640 //
//  641 //    if(!(CDataBase::GetStatus()))
//  642 //    {
//  643 //        uiLength = ResponseException(uiSlave,
//  644 //                                     uiFunctionCode,
//  645 //                                     MODBUS_EXCEPTION_ILLEGAL_FUNCTION,
//  646 //                                     puiResponse);
//  647 //    }
//  648 //    else
//  649 //    {
//  650 //        uiLength = ResponseBasis(uiSlave, uiFunctionCode, puiResponse);
//  651 //    }
//  652 //
//  653 ////    if(Storage::GetStatus() != Storage::IDLE)
//  654 ////    {
//  655 ////        return ModBus::SLAVE_DEVICE_BUSY;
//  656 ////    }
//  657 //
//  658 //    return uiLength;
//  659 //}
//  660 
//  661 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  662 int16_t CModbus::Reply(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiFrameLength)
??Reply:
//  663 {
        RCALL   ?PROLOGUE14_L09
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R7_is_cg_reg
        REQUIRE ?Register_R8_is_cg_reg
        REQUIRE ?Register_R9_is_cg_reg
        REQUIRE ?Register_R10_is_cg_reg
        REQUIRE ?Register_R11_is_cg_reg
        REQUIRE ?Register_R12_is_cg_reg
        REQUIRE ?Register_R13_is_cg_reg
        MOVW    R27:R26, R17:R16
        MOVW    R5:R4, R19:R18
        MOVW    R7:R6, R21:R20
//  664     uint16_t uiOffset = HEADER_LENGTH;
        CLR     R13
        CLR     R12
        INC     R12
//  665     int8_t uiSlave = puiRequest[uiOffset - 1];
        MOVW    R31:R30, R27:R26
        ADD     R30, R12
        ADC     R31, R13
        SBIW    R31:R30, 1
        LD      R8, Z
//  666     int8_t uiFunctionCode = puiRequest[uiOffset];
        MOVW    R31:R30, R27:R26
        ADD     R30, R12
        ADC     R31, R13
        LD      R10, Z
//  667     uint16_t uiLength = uiFrameLength;
        MOVW    R25:R24, R7:R6
//  668 
//  669     /* Filter on the Modbus unit identifier (slave) in RTU mode */
//  670     if (uiSlave != m_uiSlave && uiSlave != MODBUS_BROADCAST_ADDRESS)
        MOV     R9, R8
        LSL     R9
        SBC     R9, R9
        LDS     R16, ??m_uiSlave
        LDI     R17, 0
        CP      R8, R16
        CPC     R9, R17
        BREQ    ??Reply_1
        TST     R8
        BREQ    ??Reply_1
//  671     {
//  672         return 0;
        LDI     R16, 0
        LDI     R17, 0
        RJMP    ??Reply_2
//  673     }
//  674 
//  675     switch (uiFunctionCode)
??Reply_1:
        MOV     R11, R10
        LSL     R11
        SBC     R11, R11
        MOV     R16, R10
        CPI     R16, 2
        BRNE    ??Reply_3
//  676     {
//  677 //    case _FC_READ_COILS:
//  678 //        uiLength = ReadCoils(puiRequest, puiResponse, uiLength);
//  679 //        break;
//  680 //
//  681     case _FC_READ_DISCRETE_INPUTS:
//  682         uiLength = ReadDiscreteInputs(puiRequest, puiResponse, uiLength);
        MOVW    R21:R20, R25:R24
        MOVW    R19:R18, R5:R4
        MOVW    R17:R16, R27:R26
        RCALL   ??ReadDiscreteInputs
        MOVW    R25:R24, R17:R16
//  683         break;
        RJMP    ??Reply_4
//  684 
//  685 //    case _FC_READ_HOLDING_REGISTERS:
//  686 //        uiLength = ReadHoldingRegisters(puiRequest, puiResponse, uiLength);
//  687 //        break;
//  688 //
//  689 //    case _FC_READ_INPUT_REGISTERS:
//  690 //        uiLength = ReadInputRegisters(puiRequest, puiResponse, uiLength);
//  691 //        break;
//  692 //
//  693 //    case _FC_WRITE_SINGLE_COIL:
//  694 //        uiLength = WriteSingleCoil(puiRequest, puiResponse, uiLength);
//  695 //        break;
//  696 //
//  697 //    case _FC_WRITE_SINGLE_REGISTER:
//  698 //        uiLength = WriteSingleRegister(puiRequest, puiResponse, uiLength);
//  699 //        break;
//  700 //
//  701 //    case _FC_READ_EXCEPTION_STATUS:
//  702 //        uiLength = ReadExceptionStatus(puiRequest, puiResponse, uiLength);
//  703 //        break;
//  704 //
//  705 //    case _FC_WRITE_MULTIPLE_COILS:
//  706 //        uiLength = WriteMultipleCoils(puiRequest, puiResponse, uiLength);
//  707 //        break;
//  708 //
//  709 //    case _FC_PROGRAMMING_COMPLETION_REQUEST:
//  710 //        break;
//  711 //
//  712 //    case _FC_WRITE_MULTIPLE_REGISTERS:
//  713 //        uiLength = WriteMultipleRegisters(puiRequest, puiResponse, uiLength);
//  714 //        break;
//  715 //
//  716 //    case _FC_REPORT_SLAVE_ID:
//  717 //        uiLength = ReportSlaveID(puiRequest, puiResponse, uiLength);
//  718 //        break;
//  719 //
//  720 //    case _FC_WRITE_AND_READ_REGISTERS:
//  721 //        uiLength = WriteAndReadRegisters(puiRequest, puiResponse, uiLength);
//  722 //        break;
//  723 //
//  724 //    case _FC_DATA_EXCHANGE:
//  725 //        break;
//  726 //
//  727 //    case _FC_DATA_BASE_READ:
//  728 //        break;
//  729 //
//  730 //    case _FC_DATA_BASE_WRITE:
//  731 //        break;
//  732 //
//  733 //    case _FC_PROGRAMMING:
//  734 //        uiLength = Programming(puiRequest, puiResponse, uiLength);
//  735 //        break;
//  736 
//  737     default:
//  738         uiLength = ResponseException(uiSlave,
//  739                                      uiFunctionCode,
//  740                                      MODBUS_EXCEPTION_ILLEGAL_FUNCTION,
//  741                                      puiResponse);
??Reply_3:
        MOVW    R21:R20, R5:R4
        LDI     R18, 1
        MOV     R17, R10
        MOV     R16, R8
        RCALL   ??ResponseException
        MOVW    R25:R24, R17:R16
//  742         break;
//  743     }
//  744 
//  745     m_uiMessageLength = uiLength;
??Reply_4:
        LDI     R30, LOW(??m_uiMessageLength)
        LDI     R31, (??m_uiMessageLength) >> 8
        ST      Z, R24
        STD     Z+1, R25
//  746     return uiLength;
        MOVW    R17:R16, R25:R24
??Reply_2:
        LDI     R30, 14
        RJMP    ?EPILOGUE_B14_L09
//  747 //    return SendMessage(puiResponse, uiLength);
//  748 }

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,020H
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,021H
__?EEARL:

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DC16    0
        REQUIRE ?need_segment_init

        RSEG NEAR_F:CODE:ROOT(0)
        DC8 0, 0

        END
//  749 
//  750 ////-----------------------------------------------------------------------------------------------------
//  751 //void CModbus::SetByteFromBits(uint8_t *dest, int16_t index, const uint8_t value)
//  752 //{
//  753 //    int16_t i;
//  754 //
//  755 //    for (i=0; i<8; i++)
//  756 //    {
//  757 //        dest[index+i] = (value & (1 << i)) ? 1 : 0;
//  758 //    }
//  759 //}
//  760 //
//  761 ////-----------------------------------------------------------------------------------------------------
//  762 //void CModbus::SetBytesFromBits(uint8_t *dest, int16_t index, uint16_t nb_bits,
//  763 //                               const uint8_t *tab_byte)
//  764 //{
//  765 //    int16_t i;
//  766 //    int16_t shift = 0;
//  767 //
//  768 //    for (i = index; i < index + nb_bits; i++)
//  769 //    {
//  770 //        dest[i] = tab_byte[(i - index) / 8] & (1 << shift) ? 1 : 0;
//  771 //        /* gcc doesn't like: shift = (++shift) % 8; */
//  772 //        shift++;
//  773 //        shift %= 8;
//  774 //    }
//  775 //}
//  776 //
//  777 ////-----------------------------------------------------------------------------------------------------
//  778 //uint8_t CModbus::GetByteFromBits(const uint8_t *src, int16_t index,
//  779 //                                 uint16_t nb_bits)
//  780 //{
//  781 //    int16_t i;
//  782 //    uint8_t value = 0;
//  783 //
//  784 //    if (nb_bits > 8)
//  785 //    {
//  786 //        /* Assert is ignored if NDEBUG is set */
//  787 ////        assert(nb_bits < 8); //?
//  788 //        nb_bits = 8;
//  789 //    }
//  790 //
//  791 //    for (i=0; i < nb_bits; i++)
//  792 //    {
//  793 //        value |= (src[index+i] << i);
//  794 //    }
//  795 //
//  796 //    return value;
//  797 //}
//  798 //
//  799 ////-----------------------------------------------------------------------------------------------------
//  800 //float CModbus::GetFloat(const uint16_t *src)
//  801 //{
//  802 //    float f = 0.0f;
//  803 //    uint32_t i;
//  804 //
//  805 //    i = (((uint32_t)src[1]) << 16) + src[0];
//  806 //    memcpy(&f, &i, sizeof(float));
//  807 //
//  808 //    return f;
//  809 //}
//  810 //
//  811 ////-----------------------------------------------------------------------------------------------------
//  812 //void CModbus::SetFloat(float f, uint16_t *dest)
//  813 //{
//  814 //    uint32_t i = 0;
//  815 //
//  816 //    memcpy(&i, &f, sizeof(uint32_t));
//  817 //    dest[0] = (uint16_t)i;
//  818 //    dest[1] = (uint16_t)(i >> 16);
//  819 //}
//  820 
//  821 //-----------------------------------------------------------------------------------------------------
//  822 
//  823 
//  824 
//  825 
//  826 
//  827 
//  828 ////-----------------------------------------------------------------------------------------------------
//  829 //uint8_t CModbus::CheckConfirmation(uint8_t *puiRequest, uint16_t uiLength)
//  830 //{
//  831 //    uint16_t uiOffset = HEADER_LENGTH;
//  832 //    int8_t uiSlave = puiRequest[uiOffset - 1];
//  833 //    int8_t uiFunctionCode = puiRequest[uiOffset];
//  834 //
//  835 //    if ((m_uiSlave == uiSlave) &&
//  836 //            (m_uiFunctionCode == uiFunctionCode))
//  837 //    {
//  838 //
//  839 //        return 1;
//  840 //    }
//  841 //    else if (uiLength == (uiOffset + 2 + CRC_LENGTH) &&
//  842 //             (uiFunctionCode & 0x80))
//  843 //    {
//  844 //        /* EXCEPTION CODE RECEIVED */
//  845 //        int8_t uiExceptionCode =
//  846 //            puiRequest[uiOffset + MODBUS_EXCEPTION_CODE_OFFSET];
//  847 //        if (uiExceptionCode < MODBUS_EXCEPTION_MAX)
//  848 //        {
//  849 //            return MODBUS_ENOBASE + uiExceptionCode;
//  850 //        }
//  851 //        else
//  852 //        {
//  853 //            return EMBBADEXC;
//  854 //        }
//  855 //    }
//  856 //}
//  857 //
//  858 ////-----------------------------------------------------------------------------------------------------
//  859 /////* Reads IO status */
//  860 ////static int read_io_status(uint8_t uiSlave,
//  861 ////                          uint8_t uiFunctionCode,
//  862 ////                          uint16_t uiAddress,
//  863 ////                          uint16_t uiBitNumber,
//  864 ////                          uint8_t *puiRequest)
//  865 //////                                    (modbus_t *ctx, int function,
//  866 //////                          int addr, int nb, unsigned char *dest)
//  867 ////{
//  868 ////    uint16_t uiLength;
//  869 ////
//  870 ////    int rc;
//  871 ////    int req_length;
//  872 ////
//  873 ////    unsigned char req[_MIN_REQ_LENGTH];
//  874 ////    unsigned char rsp[MAX_MESSAGE_LENGTH];
//  875 ////
//  876 //////    req_length = ctx->backend->build_request_basis(ctx, function, addr, nb, req);
//  877 ////
//  878 ////    uiLength = RequestBasis(uiSlave,
//  879 ////                            uiFunctionCode,
//  880 ////                            uiAddress,
//  881 ////                            uiBitNumber,
//  882 ////                            puiRequest);
//  883 ////
//  884 //////    rc = send_msg(ctx, req, req_length);
//  885 ////
//  886 ////
//  887 ////    if (SendMessage(puiRequest, uiLength))
//  888 ////    {
//  889 ////        int i, temp, bit;
//  890 ////        int pos = 0;
//  891 ////        int offset;
//  892 ////        int offset_end;
//  893 ////
//  894 ////        rc = receive_msg(ctx, rsp, MSG_CONFIRMATION);
//  895 ////        if (rc == -1)
//  896 ////            return -1;
//  897 ////
//  898 ////        rc = check_confirmation(ctx, req, rsp, rc);
//  899 ////        if (rc == -1)
//  900 ////            return -1;
//  901 ////
//  902 ////        offset = ctx->backend->header_length + 2;
//  903 ////        offset_end = offset + rc;
//  904 ////        for (i = offset; i < offset_end; i++)
//  905 ////        {
//  906 ////            /* Shift reg hi_byte to temp */
//  907 ////            temp = rsp[i];
//  908 ////
//  909 ////            for (bit = 0x01; (bit & 0xff) && (pos < nb);)
//  910 ////            {
//  911 ////                dest[pos++] = (temp & bit) ? TRUE : FALSE;
//  912 ////                bit = bit << 1;
//  913 ////            }
//  914 ////
//  915 ////        }
//  916 ////    }
//  917 ////
//  918 ////    return rc;
//  919 ////}
//  920 //
//  921 ////-----------------------------------------------------------------------------------------------------
//  922 ///* Reads the boolean status of bits and sets the array elements
//  923 //   in the destination to TRUE or FALSE (single bits). */
//  924 //int8_t CModbus::ReadCoilsRequest(uint16_t uiAddress,
//  925 //                                  uint16_t uiBitNumber)
//  926 //{
//  927 //    if (uiBitNumber > MODBUS_MAX_READ_BITS)
//  928 //    {
//  929 //        return EMBMDATA;
//  930 //    }
//  931 //
//  932 //    if (MessengerIsReady())
//  933 //    {
//  934 //        m_uiFunctionCode = _FC_READ_COILS;
//  935 //        m_uiMessageLength = RequestBasis(m_uiSlave,
//  936 //                                         m_uiFunctionCode,
//  937 //                                         uiAddress,
//  938 //                                         uiBitNumber,
//  939 //                                         m_puiTxBuffer);
//  940 //        FlowControlSet(FRAME_TRANSMIT_REQUEST);
//  941 //        return 1;
//  942 //    }
//  943 //    else
//  944 //    {
//  945 //        return 0;
//  946 //    }
//  947 //}
//  948 //
//  949 ////-----------------------------------------------------------------------------------------------------
//  950 //int16_t CModbus::ReadCoilsReply(uint8_t *puiDestination)
//  951 //{
//  952 //
//  953 //    if (MessengerIsReady())
//  954 //    {
//  955 //
//  956 //        FlowControlSet(FRAME_TRANSMIT_REQUEST);
//  957 //        return 1;
//  958 //    }
//  959 //    else
//  960 //    {
//  961 //        return 0;
//  962 //    }
//  963 //}
// 
//  87 bytes in segment ABSOLUTE
// 522 bytes in segment CODE
//   6 bytes in segment INITTAB
//   2 bytes in segment NEAR_F
//  27 bytes in segment NEAR_Z
// 
// 524 bytes of CODE memory (+  6 bytes shared)
//  27 bytes of DATA memory (+ 87 bytes shared)
//
//Errors: none
//Warnings: 6
