///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.10.6.1378 for Atmel AVR          08/May/2022  01:27:24
// Copyright 1996-2018 IAR Systems AB.
//
//    Source file  =  
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\src\Mvsn21.cpp
//    Command line =  
//        -f C:\Users\ghost\AppData\Local\Temp\EW4D89.tmp
//        (--string_literals_in_flash
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\src\Mvsn21.cpp --cpu=m48
//        -ms -o D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Debug\Obj -lB
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Debug\List
//        --initializers_in_flash --root_variables --no_cse --no_inline
//        --no_code_motion --no_cross_call --no_clustering --no_tbaa --debug
//        -DENABLE_BIT_DEFINITIONS -e -I
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\include\ -I
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Modbus\ --eeprom_size
//        256 --dlib --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 8.0\avr\LIB\DLIB\dlAVR-1s-ec_mul-n.h" -On --eec++)
//    Locale       =  Russian_RUS.1251
//    List file    =  
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Debug\List\Mvsn21.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME Mvsn21

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        ERROR
//NOTE: This module defines or uses C++ features that are not
//      accessible from assembler code. Assembling this file will
//      not produce an equivalent object file to the one produced
//      by the C++ compiler.

        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBLIC ??MeasureFsm
        PUBWEAK ??MeasureIsComlete
        PUBLIC ??m_aucRtuCoilsArray
        PUBLIC ??m_aucRtuDiscreteInputsArray
        PUBLIC ??m_aucRtuHoldingRegistersArray
        PUBLIC ??m_aucRtuInputRegistersArray
        PUBLIC ??m_aui8ReceiveMessageBuff
        PUBLIC ??m_aui8TransmitMessageBuff
        PUBLIC ??m_uiChannel
        PUBLIC ??m_uiFlowControl
        PUBLIC ??m_uiMeasureFlowControl
        PUBLIC ??m_uiMessageLength
        PUBLIC ??m_uiType
        PUBWEAK _A_ACSR
        PUBWEAK _A_ADC
        PUBWEAK _A_ADCSRA
        PUBWEAK _A_ADCSRB
        PUBWEAK _A_ADMUX
        PUBWEAK _A_ASSR
        PUBWEAK _A_CLKPR
        PUBWEAK _A_DDRB
        PUBWEAK _A_DDRC
        PUBWEAK _A_DDRD
        PUBWEAK _A_DIDR0
        PUBWEAK _A_DIDR1
        PUBWEAK _A_EEAR
        PUBWEAK _A_EECR
        PUBWEAK _A_EEDR
        PUBWEAK _A_EICRA
        PUBWEAK _A_EIFR
        PUBWEAK _A_EIMSK
        PUBWEAK _A_GPIOR0
        PUBWEAK _A_GPIOR1
        PUBWEAK _A_GPIOR2
        PUBWEAK _A_GTCCR
        PUBWEAK _A_ICR1
        PUBWEAK _A_MCUCR
        PUBWEAK _A_MCUSR
        PUBWEAK _A_OCR0A
        PUBWEAK _A_OCR0B
        PUBWEAK _A_OCR1A
        PUBWEAK _A_OCR1B
        PUBWEAK _A_OCR2A
        PUBWEAK _A_OCR2B
        PUBWEAK _A_OSCCAL
        PUBWEAK _A_PCICR
        PUBWEAK _A_PCIFR
        PUBWEAK _A_PCMSK0
        PUBWEAK _A_PCMSK1
        PUBWEAK _A_PCMSK2
        PUBWEAK _A_PINB
        PUBWEAK _A_PINC
        PUBWEAK _A_PIND
        PUBWEAK _A_PORTB
        PUBWEAK _A_PORTC
        PUBWEAK _A_PORTD
        PUBWEAK _A_PRR
        PUBWEAK _A_SMCR
        PUBWEAK _A_SP
        PUBWEAK _A_SPCR
        PUBWEAK _A_SPDR
        PUBWEAK _A_SPMCSR
        PUBWEAK _A_SPSR
        PUBWEAK _A_SREG
        PUBWEAK _A_TCCR0A
        PUBWEAK _A_TCCR0B
        PUBWEAK _A_TCCR1A
        PUBWEAK _A_TCCR1B
        PUBWEAK _A_TCCR1C
        PUBWEAK _A_TCCR2A
        PUBWEAK _A_TCCR2B
        PUBWEAK _A_TCNT0
        PUBWEAK _A_TCNT1
        PUBWEAK _A_TCNT2
        PUBWEAK _A_TIFR0
        PUBWEAK _A_TIFR1
        PUBWEAK _A_TIFR2
        PUBWEAK _A_TIMSK0
        PUBWEAK _A_TIMSK1
        PUBWEAK _A_TIMSK2
        PUBWEAK _A_TWAMR
        PUBWEAK _A_TWAR
        PUBWEAK _A_TWBR
        PUBWEAK _A_TWCR
        PUBWEAK _A_TWDR
        PUBWEAK _A_TWSR
        PUBWEAK _A_UBRR0
        PUBWEAK _A_UCSR0A
        PUBWEAK _A_UCSR0B
        PUBWEAK _A_UCSR0C
        PUBWEAK _A_UDR0
        PUBWEAK _A_WDTCSR
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR

`?<Name CMvsn21 19>` SYMBOL "CMvsn21"
??m_aucRtuCoilsArray SYMBOL "m_aucRtuCoilsArray", `?<Name CMvsn21 19>`
??m_aucRtuDiscreteInputsArray SYMBOL "m_aucRtuDiscreteInputsArray", `?<Name CMvsn21 19>`
??m_aucRtuHoldingRegistersArray SYMBOL "m_aucRtuHoldingRegistersArray", `?<Name CMvsn21 19>`
??m_aucRtuInputRegistersArray SYMBOL "m_aucRtuInputRegistersArray", `?<Name CMvsn21 19>`
??m_aui8ReceiveMessageBuff SYMBOL "m_aui8ReceiveMessageBuff", `?<Name CMvsn21 19>`
??m_aui8TransmitMessageBuff SYMBOL "m_aui8TransmitMessageBuff", `?<Name CMvsn21 19>`
??m_uiChannel       SYMBOL "m_uiChannel", `?<Name CMvsn21 19>`
??m_uiFlowControl   SYMBOL "m_uiFlowControl", `?<Name CMvsn21 19>`
??m_uiMeasureFlowControl SYMBOL "m_uiMeasureFlowControl", `?<Name CMvsn21 19>`
??m_uiMessageLength SYMBOL "m_uiMessageLength", `?<Name CMvsn21 19>`
??m_uiType          SYMBOL "m_uiType", `?<Name CMvsn21 19>`

        EXTERN ??ChannelSelect
        EXTERN ??Disable
        EXTERN ??Enable
        EXTERN ??GetMeasureValue
        EXTERN ??Start
        EXTERN ??StatusCheck
        EXTERN ??Stop

// D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\src\Mvsn21.cpp
//    1 //-----------------------------------------------------------------------------------------------------
//    2 //  Source      : FileName.cpp
//    3 //  Created     : 01.06.2022
//    4 //  Author      : Alexandr Volvenkin
//    5 //  email       : aav-36@mail.ru
//    6 //  GitHub      : https://github.com/AlexandrVolvenkin
//    7 //-----------------------------------------------------------------------------------------------------
//    8 
//    9 #include "Mvsn21.h"
//   10 #include "Platform.h"

        ASEGN ABSOLUTE:DATA:ROOT,0c6H
// union <unnamed> volatile __io _A_UDR0
_A_UDR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c4H
// union <unnamed> volatile __io _A_UBRR0
_A_UBRR0:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,0c2H
// union <unnamed> volatile __io _A_UCSR0C
_A_UCSR0C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c1H
// union <unnamed> volatile __io _A_UCSR0B
_A_UCSR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c0H
// union <unnamed> volatile __io _A_UCSR0A
_A_UCSR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bdH
// union <unnamed> volatile __io _A_TWAMR
_A_TWAMR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bcH
// union <unnamed> volatile __io _A_TWCR
_A_TWCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bbH
// union <unnamed> volatile __io _A_TWDR
_A_TWDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0baH
// union <unnamed> volatile __io _A_TWAR
_A_TWAR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b9H
// union <unnamed> volatile __io _A_TWSR
_A_TWSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b8H
// union <unnamed> volatile __io _A_TWBR
_A_TWBR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b6H
// union <unnamed> volatile __io _A_ASSR
_A_ASSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b4H
// union <unnamed> volatile __io _A_OCR2B
_A_OCR2B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b3H
// union <unnamed> volatile __io _A_OCR2A
_A_OCR2A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b2H
// union <unnamed> volatile __io _A_TCNT2
_A_TCNT2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b1H
// union <unnamed> volatile __io _A_TCCR2B
_A_TCCR2B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b0H
// union <unnamed> volatile __io _A_TCCR2A
_A_TCCR2A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,08aH
// union <unnamed> volatile __io _A_OCR1B
_A_OCR1B:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,088H
// union <unnamed> volatile __io _A_OCR1A
_A_OCR1A:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,086H
// union <unnamed> volatile __io _A_ICR1
_A_ICR1:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,084H
// union <unnamed> volatile __io _A_TCNT1
_A_TCNT1:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,082H
// union <unnamed> volatile __io _A_TCCR1C
_A_TCCR1C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,081H
// union <unnamed> volatile __io _A_TCCR1B
_A_TCCR1B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,080H
// union <unnamed> volatile __io _A_TCCR1A
_A_TCCR1A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07fH
// union <unnamed> volatile __io _A_DIDR1
_A_DIDR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07eH
// union <unnamed> volatile __io _A_DIDR0
_A_DIDR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07cH
// union <unnamed> volatile __io _A_ADMUX
_A_ADMUX:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07bH
// union <unnamed> volatile __io _A_ADCSRB
_A_ADCSRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07aH
// union <unnamed> volatile __io _A_ADCSRA
_A_ADCSRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,078H
// union <unnamed> volatile __io _A_ADC
_A_ADC:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,070H
// union <unnamed> volatile __io _A_TIMSK2
_A_TIMSK2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06fH
// union <unnamed> volatile __io _A_TIMSK1
_A_TIMSK1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06eH
// union <unnamed> volatile __io _A_TIMSK0
_A_TIMSK0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06dH
// union <unnamed> volatile __io _A_PCMSK2
_A_PCMSK2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06cH
// union <unnamed> volatile __io _A_PCMSK1
_A_PCMSK1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06bH
// union <unnamed> volatile __io _A_PCMSK0
_A_PCMSK0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,069H
// union <unnamed> volatile __io _A_EICRA
_A_EICRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,068H
// union <unnamed> volatile __io _A_PCICR
_A_PCICR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,066H
// union <unnamed> volatile __io _A_OSCCAL
_A_OSCCAL:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,064H
// union <unnamed> volatile __io _A_PRR
_A_PRR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,061H
// union <unnamed> volatile __io _A_CLKPR
_A_CLKPR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,060H
// union <unnamed> volatile __io _A_WDTCSR
_A_WDTCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05fH
// union <unnamed> volatile __io _A_SREG
_A_SREG:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05dH
// union <unnamed> volatile __io _A_SP
_A_SP:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,057H
// union <unnamed> volatile __io _A_SPMCSR
_A_SPMCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,055H
// union <unnamed> volatile __io _A_MCUCR
_A_MCUCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,054H
// union <unnamed> volatile __io _A_MCUSR
_A_MCUSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,053H
// union <unnamed> volatile __io _A_SMCR
_A_SMCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,050H
// union <unnamed> volatile __io _A_ACSR
_A_ACSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04eH
// union <unnamed> volatile __io _A_SPDR
_A_SPDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04dH
// union <unnamed> volatile __io _A_SPSR
_A_SPSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04cH
// union <unnamed> volatile __io _A_SPCR
_A_SPCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04bH
// union <unnamed> volatile __io _A_GPIOR2
_A_GPIOR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04aH
// union <unnamed> volatile __io _A_GPIOR1
_A_GPIOR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,048H
// union <unnamed> volatile __io _A_OCR0B
_A_OCR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,047H
// union <unnamed> volatile __io _A_OCR0A
_A_OCR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,046H
// union <unnamed> volatile __io _A_TCNT0
_A_TCNT0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,045H
// union <unnamed> volatile __io _A_TCCR0B
_A_TCCR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,044H
// union <unnamed> volatile __io _A_TCCR0A
_A_TCCR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,043H
// union <unnamed> volatile __io _A_GTCCR
_A_GTCCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,041H
// union <unnamed> volatile __io _A_EEAR
_A_EEAR:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,040H
// union <unnamed> volatile __io _A_EEDR
_A_EEDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03fH
// union <unnamed> volatile __io _A_EECR
_A_EECR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03eH
// union <unnamed> volatile __io _A_GPIOR0
_A_GPIOR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03dH
// union <unnamed> volatile __io _A_EIMSK
_A_EIMSK:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03cH
// union <unnamed> volatile __io _A_EIFR
_A_EIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03bH
// union <unnamed> volatile __io _A_PCIFR
_A_PCIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,037H
// union <unnamed> volatile __io _A_TIFR2
_A_TIFR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,036H
// union <unnamed> volatile __io _A_TIFR1
_A_TIFR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,035H
// union <unnamed> volatile __io _A_TIFR0
_A_TIFR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02bH
// union <unnamed> volatile __io _A_PORTD
_A_PORTD:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02aH
// union <unnamed> volatile __io _A_DDRD
_A_DDRD:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,029H
// union <unnamed> volatile __io _A_PIND
_A_PIND:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,028H
// union <unnamed> volatile __io _A_PORTC
_A_PORTC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,027H
// union <unnamed> volatile __io _A_DDRC
_A_DDRC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,026H
// union <unnamed> volatile __io _A_PINC
_A_PINC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,025H
// union <unnamed> volatile __io _A_PORTB
_A_PORTB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,024H
// union <unnamed> volatile __io _A_DDRB
_A_DDRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,023H
// union <unnamed> volatile __io _A_PINB
_A_PINB:
        DS8 1

        RSEG CODE:CODE:NOROOT(1)
// __version_3 bool CAdc::MeasureIsComlete()
??MeasureIsComlete:
        LDS     R16, _A_ADCSRA
        MOV     R17, R16
        SBRS    R17, 4
        RJMP    ??MeasureIsComlete_1
        LDS     R16, 122
        ORI     R16, 0x10
        STS     122, R16
        LDI     R16, 1
        RET
??MeasureIsComlete_1:
        LDI     R16, 0
        RET
        REQUIRE _A_ADCSRA
//   11 #include "Crc.h"
//   12 #include "ModbusRTU.h"
//   13 

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   14 uint8_t CMvsn21::m_uiType;
??m_uiType:
        DS8 1
//   15 //CDriver* CMvsn21::m_pxDriver;

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   16 uint8_t CMvsn21::m_uiFlowControl;
??m_uiFlowControl:
        DS8 1

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   17 uint16_t CMvsn21::m_uiMessageLength;
??m_uiMessageLength:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   18 uint8_t CMvsn21::m_uiChannel;
??m_uiChannel:
        DS8 1

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   19 uint8_t CMvsn21::m_uiMeasureFlowControl;
??m_uiMeasureFlowControl:
        DS8 1
//   20 //TChipChannelData CMvsn21::axChipsChannelsData[CHIP_NUMBER];
//   21 //CMeasurementChannel CMvsn21::axMasterMeasurementChannels[];
//   22 //CMeasurementChannel CMvsn21::axSlave1MeasurementChannels[];
//   23 //CMeasurementChannel CMvsn21::axSlave2MeasurementChannels[];
//   24 // Сопоставление входа каналу.
//   25 //__flash TChannelRemap CMvsn21::axMeasurementChannelRemap[] =
//   26 //{
//   27 //    // Нумерация входов сверху вниз.
//   28 //    // разъём X1.
//   29 //    {0, 6},
//   30 //    {0, 7},
//   31 //    {0, 0},
//   32 //    {0, 1},
//   33 //    {0, 2},
//   34 //    {0, 3},
//   35 //    // разъём X2.
//   36 //    {0, 4},
//   37 //    {0, 5},
//   38 //    {1, 6},
//   39 //    {1, 7},
//   40 //    {1, 0},
//   41 //    {1, 1},
//   42 //    // разъём X3.
//   43 //    {1, 2},
//   44 //    {1, 3},
//   45 //    {1, 4},
//   46 //    {1, 5},
//   47 //    {2, 6},
//   48 //    {2, 7},
//   49 //    // разъём X4.
//   50 //    {2, 0},
//   51 //    {2, 1},
//   52 //    {2, 2},
//   53 //    {2, 3},
//   54 //    {2, 4},
//   55 //    {2, 5},
//   56 //};
//   57 //uint8_t CMvsn21::auiDiscreteInputBitData[];
//   58 

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   59 uint8_t CMvsn21::m_aucRtuCoilsArray[];
??m_aucRtuCoilsArray:
        DS8 8

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   60 uint8_t CMvsn21::m_aucRtuDiscreteInputsArray[];
??m_aucRtuDiscreteInputsArray:
        DS8 16

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   61 uint16_t CMvsn21::m_aucRtuHoldingRegistersArray[];
??m_aucRtuHoldingRegistersArray:
        DS8 16

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   62 uint16_t CMvsn21::m_aucRtuInputRegistersArray[];
??m_aucRtuInputRegistersArray:
        DS8 16

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   63 uint8_t CMvsn21::m_aui8ReceiveMessageBuff[];
??m_aui8ReceiveMessageBuff:
        DS8 32

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   64 uint8_t CMvsn21::m_aui8TransmitMessageBuff[];
??m_aui8TransmitMessageBuff:
        DS8 32
//   65 //uint8_t CMvsn21::m_auiSpiRxBuffer[];
//   66 //uint8_t CMvsn21::m_auiSpiTxBuffer[];
//   67 
//   68 ////-----------------------------------------------------------------------------------------------------
//   69 //CMvsn21::CMvsn21(uint8_t uiType, CDriver* pxDriver)// :
//   70 ////    m_uiType(uiType),
//   71 ////    m_pxDriver(pxDriver)
//   72 //{
//   73 //
//   74 //}
//   75 
//   76 ////-----------------------------------------------------------------------------------------------------
//   77 //CMvsn21::CMvsn21(uint8_t uiType)// :
//   78 ////    m_uiType(uiType),
//   79 ////    m_pxDriver(pxDriver)
//   80 //{
//   81 //
//   82 //}
//   83 //
//   84 ////-----------------------------------------------------------------------------------------------------
//   85 //CMvsn21::~CMvsn21()
//   86 //{
//   87 //    //dtor
//   88 //}
//   89 
//   90 ////-----------------------------------------------------------------------------------------------------
//   91 //void CMvsn21::SlaveSelectInterruptEnable(void)
//   92 //{
//   93 //
//   94 //}
//   95 //
//   96 ////-----------------------------------------------------------------------------------------------------
//   97 //void CMvsn21::SlaveSelectInterruptDisable(void)
//   98 //{
//   99 //
//  100 //}
//  101 //
//  102 ////-----------------------------------------------------------------------------------------------------
//  103 //void CMvsn21::SpiBusExchangeEnable(void)
//  104 //{
//  105 //    CPlatform::Int0InterruptEnable();
//  106 //    m_uiFlowControl = FSM_START;
//  107 //}
//  108 //
//  109 ////-----------------------------------------------------------------------------------------------------
//  110 //void CMvsn21::SpiBusExchangeDisable(void)
//  111 //{
//  112 //    CPlatform::Int0InterruptDisable();
//  113 //}
//  114 //
//  115 ////-----------------------------------------------------------------------------------------------------
//  116 //void CMvsn21::Reset(void)
//  117 //{
//  118 //    m_uiMessageLength = 0;
//  119 //    CSpi::Reset();
//  120 //}
//  121 //
//  122 ////-----------------------------------------------------------------------------------------------------
//  123 //uint8_t CMvsn21::Select(void)
//  124 //{
//  125 //    return CSpi::ByteIsReceived();
//  126 //}
//  127 //
//  128 ////-----------------------------------------------------------------------------------------------------
//  129 //int16_t CMvsn21::Exchange(void)
//  130 //{
//  131 //    return CSpi::Exchange();
//  132 //}
//  133 //
//  134 ////-----------------------------------------------------------------------------------------------------------------
//  135 //uint8_t CMvsn21::FrameIsReceived(void)
//  136 //{
//  137 //    return CSpi::m_bfDataExchangeIsOccur;
//  138 //};
//  139 //
//  140 ////-----------------------------------------------------------------------------------------------------------------
//  141 //uint16_t CMvsn21::GetFrameLength(void)
//  142 //{
//  143 //    return CSpi::GetFrameLength();
//  144 //}
//  145 //
//  146 ////-----------------------------------------------------------------------------------------------------------------
//  147 //int8_t CMvsn21::FrameCheck(void)
//  148 //{
//  149 ////    if (CUart::m_nuiRxBuffByteCounter < _MIN_MESSAGE_LENGTH)
//  150 ////    {
//  151 ////        return 0;
//  152 ////    }
//  153 ////
//  154 ////    uint16_t uiCrc = ((static_cast<uint16_t>(m_puiRxBuffer[CUart::m_nuiRxBuffByteCounter - 2]) << 8) |
//  155 ////                      (static_cast<uint16_t>(m_puiRxBuffer[CUart::m_nuiRxBuffByteCounter - 1])));
//  156 ////
//  157 ////    if (usCrc16(m_puiRxBuffer,
//  158 ////                (CUart::m_nuiRxBuffByteCounter - _MVSN21_RTU_CHECKSUM_LENGTH)) == uiCrc)
//  159 ////    {
//  160 ////        return 1;
//  161 ////    }
//  162 ////    else
//  163 ////    {
//  164 ////        return 0;
//  165 ////    }
//  166 //}
//  167 //
//  168 ////-----------------------------------------------------------------------------------------------------------------
//  169 //int8_t CMvsn21::FrameCheck(uint8_t *puiSource, uint16_t uiLength)
//  170 //{
//  171 ////    if (uiLength < _MIN_MESSAGE_LENGTH)
//  172 ////    {
//  173 ////        return 0;
//  174 ////    }
//  175 ////
//  176 ////    uint16_t uiCrc = ((static_cast<uint16_t>(puiSource[uiLength - 2]) << 8) |
//  177 ////                      (static_cast<uint16_t>(puiSource[uiLength - 1])));
//  178 ////
//  179 ////    if (usCrc16(puiSource,
//  180 ////                (uiLength - _MVSN21_RTU_CHECKSUM_LENGTH)) == uiCrc)
//  181 ////    {
//  182 ////        return 1;
//  183 ////    }
//  184 ////    else
//  185 ////    {
//  186 ////        return 0;
//  187 ////    }
//  188 //}
//  189 
//  190 //-----------------------------------------------------------------------------------------------------
//  191 //void CMvsn21::ChannelsToDiscreteInput(void)
//  192 //{
//  193 //    uint8_t uiLength = 0;
//  194 //    uint8_t *puiMessage = auiDiscreteInputBitData;
//  195 ////    TChannelRemap __flash *pxMeasurementChannelRemap;
//  196 ////    pxMeasurementChannelRemap = &axMeasurementChannelRemap[0];
//  197 //
//  198 //    // Протокол обмена данными по шине Spi.
//  199 //    // Первый байт - пустой.
//  200 //    puiMessage[uiLength++] = 0;
//  201 ////    // Второй байт - "эхо".
//  202 ////    puiMessage[uiLength++] = COMMAND_READ_DATA;
//  203 //    // Третий байт - команда обмен данными.
//  204 //    puiMessage[uiLength++] = COMMAND_READ_DATA;
//  205 //
//  206 //
//  207 //    // Следующие шесть байт - данные состояния дискретных входов.
//  208 //    // Упакуем двухбитовые данные состояния измерительных каналов всех чипов в дискретные входы.
//  209 //    // i - индекс дискретных входов.
//  210 //    for (int8_t i = 0; i < DISCRETE_INPUT_NUMBER; )
//  211 //    {
//  212 //        puiMessage[uiLength] = 0;
//  213 ////        // Упакуем двухбитовые данные состояния восьми измерительных каналов одного чипа в дискретные входы.
//  214 //        // Упакуем двухбитовые данные состояния четырёх измерительных каналов в байт по четыре дискретных входа.
//  215 //        for (int8_t j= 0;
//  216 //                j < (CHANNELS_IN_BYTE * MEASURE_CHANNEL_STATE_BIT_NUMBER);
//  217 //                j += MEASURE_CHANNEL_STATE_BIT_NUMBER)
//  218 //        {
//  219 //            // Упаковали все данные состояния измерительных каналов?
//  220 //            if (i < DISCRETE_INPUT_NUMBER)
//  221 //            {
//  222 //                // Отобразим данные состояния измерительных каналов на дискретные входы во временный буфер.
//  223 //                puiMessage[uiLength] |=
//  224 //                    // Следующие два бита в байте.
//  225 //                    // Выберем канал по индексу чипа, карты сопоставления измерительных каналов со входами модуля.
//  226 //                    ((axChipsChannelsData[axMeasurementChannelRemap[i].uiChip].
//  227 //                      // Выберем канал по индексу входа модуля, карты сопоставления измерительных каналов со входами модуля.
//  228 //                      axMeasurementChannels[axMeasurementChannelRemap[i].uiChannel].
//  229 //                      // Состояние измерительного канала занимает два младших бита.
//  230 //                      m_uiState & 0x03) << j);
//  231 //                // Следующий дискретный вход.
//  232 //                i++;
//  233 //            }
//  234 //            else
//  235 //            {
//  236 //                // Упаковали все данные состояния измерительных каналов.
//  237 //                goto EndStateDataPack;
//  238 //            }
//  239 //        }
//  240 //        // Следующий байт.
//  241 //        uiLength++;
//  242 //        puiMessage[uiLength] = 0;
//  243 //    }
//  244 //
//  245 //EndStateDataPack:
//  246 //
//  247 //    // Последний байт - сумма всех байт начиная с третьего(пустой байт и "эхо" не учитываются).
//  248 //    puiMessage[uiLength] =
//  249 //        usCrcSummOneByteCalculation(&puiMessage[2], (uiLength - 2));
//  250 //}
//  251 
//  252 ////-----------------------------------------------------------------------------------------------------------------
//  253 //int16_t CMvsn21::ReportType(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  254 //{
//  255 ////    *(puiResponse - 1) = 4;
//  256 ////    puiResponse[0] = 2;
//  257 //    uint8_t uiCrc = (COMMAND_REPORT_TYPE + MODULE_TYPE_MVSN21);
//  258 ////    puiResponse[uiLength++] = 0;
//  259 //    puiResponse[uiLength++] = COMMAND_REPORT_TYPE;
//  260 //    puiResponse[uiLength++] = MODULE_TYPE_MVSN21;
//  261 //    puiResponse[uiLength++] = uiCrc;
//  262 //
//  263 //    return uiLength;
//  264 //}
//  265 //
//  266 ////-----------------------------------------------------------------------------------------------------------------
//  267 //int16_t CMvsn21::ReadData(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiLength)
//  268 //{
//  269 ////    // Закончено измерение входных каналов?
//  270 ////    if (m_uiMeasureFlowControl == FSM_IDDLE)
//  271 ////    {
//  272 //    memcpy(puiResponse, auiDiscreteInputBitData, 10);
//  273 ////    }
//  274 ////    else
//  275 ////    {
//  276 ////        // Протокол обмена данными по шине Spi.
//  277 ////        // Первый байт - пустой.
//  278 ////        puiResponse[uiLength++] = 0;
//  279 ////        // Второй байт - "эхо".
//  280 ////        puiResponse[uiLength++] = COMMAND_DATA_NOT_READY;
//  281 ////        // Третий байт - команда обмен данными.
//  282 ////        puiResponse[uiLength++] = COMMAND_DATA_NOT_READY;
//  283 ////
//  284 ////
//  285 //////    // Последний байт - сумма всех байт начиная с третьего(пустой байт и "эхо" не учитываются).
//  286 //////    puiMessage[uiLength] =
//  287 //////        usCrcSummOneByteCalculation(&puiMessage[2], (uiLength - 2));
//  288 ////    }
//  289 //    return uiLength;
//  290 //}
//  291 
//  292 ////-----------------------------------------------------------------------------------------------------------------
//  293 //int16_t CMvsn21::SpiReply(uint8_t *puiRequest, uint8_t *puiResponse, uint16_t uiFrameLength)
//  294 //{
//  295 //    uint16_t uiLength = uiFrameLength;
//  296 //    // Какой поступил запрос?
//  297 //    switch (puiRequest[0])
//  298 //    {
//  299 //    case COMMAND_REPORT_TYPE:
//  300 //        uiLength = ReportType(puiRequest, puiResponse, uiLength);
//  301 //        break;
//  302 //
//  303 //    case COMMAND_READ_DATA:
//  304 //        uiLength = ReadData(puiRequest, puiResponse, uiLength);
//  305 //        break;
//  306 //
//  307 //    case COMMAND_READ_DATA_BASE:
//  308 ////        uiLength = ReadHoldingRegisters(puiRequest, puiResponse, uiLength);
//  309 //        break;
//  310 //
//  311 //    case COMMAND_WRITE_DATA_BASE:
//  312 ////        uiLength = ReadInputRegisters(puiRequest, puiResponse, uiLength);
//  313 //        break;
//  314 //
//  315 //    default:
//  316 //        break;
//  317 //    }
//  318 //    return uiLength;
//  319 //}
//  320 
//  321 ////-----------------------------------------------------------------------------------------------------------------
//  322 //void CMvsn21::SpiFsm(void)
//  323 //{
//  324 //    int16_t iReceivedCounter;
//  325 //
//  326 //    switch (m_uiFlowControl)
//  327 //    {
//  328 //    case FSM_IDDLE:
//  329 //        break;
//  330 //
//  331 //    case FSM_START:
//  332 //        Reset();
//  333 //        m_uiFlowControl = FSM_WAITING_MESSAGE;
//  334 //        break;
//  335 //
//  336 //    case FSM_WAITING_MESSAGE:
//  337 //        if (Select())
//  338 //        {
//  339 //            iReceivedCounter = Exchange();
//  340 //
//  341 //            if (iReceivedCounter > 0)
//  342 //            {
//  343 //                m_uiMessageLength += iReceivedCounter;
//  344 //
//  345 //                if (SpiReply(CSpi::m_puiRxBuffer, CSpi::m_puiTxBuffer, m_uiMessageLength))
//  346 //                {
//  347 //                    m_uiFlowControl = FSM_DATA_EXCHANGE_END_WAITING;
//  348 //                }
//  349 //                else
//  350 //                {
//  351 //                    m_uiFlowControl = FSM_IDDLE;
//  352 //                }
//  353 //            }
//  354 //            else if (iReceivedCounter == -1)
//  355 //            {
//  356 //                m_uiFlowControl = FSM_IDDLE;
//  357 //            }
//  358 //        }
//  359 //
//  360 //        break;
//  361 //
//  362 //    case FSM_DATA_EXCHANGE_END_WAITING:
//  363 //
//  364 //        break;
//  365 //
//  366 //    default:
//  367 //        break;
//  368 //    }
//  369 //
//  370 //}
//  371 
//  372 ////-----------------------------------------------------------------------------------------------------
//  373 //uint8_t CMvsn21::ContinuousMeasure(void)
//  374 //{
//  375 //    if (m_uiChannel < MEASURE_CHANNEL_NUMBER)
//  376 //    {
//  377 //        CAdc::ChannelSelect(m_uiChannel++);
//  378 //        CAdc::Start();
//  379 //        return 0;
//  380 //    }
//  381 //    else
//  382 //    {
//  383 //        return 1;
//  384 //    }
//  385 //}
//  386 
//  387 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  388 void CMvsn21::MeasureFsm(void)
??MeasureFsm:
//  389 {
        ST      -Y, R24
//  390     switch (m_uiMeasureFlowControl)
        LDS     R16, ??m_uiMeasureFlowControl
        SUBI    R16, 0
        BREQ    ??MeasureFsm_1
        DEC     R16
        BREQ    ??MeasureFsm_2
        SUBI    R16, 9
        BREQ    ??MeasureFsm_3
        RJMP    ??MeasureFsm_4
//  391     {
//  392     case FSM_IDDLE:
//  393         break;
??MeasureFsm_1:
        RJMP    ??MeasureFsm_4
//  394 
//  395     case FSM_START:
//  396         m_uiChannel = 0;
??MeasureFsm_2:
        LDI     R16, 0
        STS     ??m_uiChannel, R16
//  397         CAdc::ChannelSelect(m_uiChannel);
        LDS     R16, ??m_uiChannel
        RCALL   ??ChannelSelect
//  398         CAdc::Enable();
        RCALL   ??Enable
//  399         CAdc::Start();
        RCALL   ??Start
//  400         m_uiMeasureFlowControl = FSM_CONTINUOUS_MEASURE;
        LDI     R16, 10
        STS     ??m_uiMeasureFlowControl, R16
//  401         break;
        RJMP    ??MeasureFsm_4
//  402 
//  403     case FSM_CONTINUOUS_MEASURE:
//  404         if (CAdc::MeasureIsComlete())
??MeasureFsm_3:
        RCALL   ??MeasureIsComlete
        TST     R16
        BREQ    ??MeasureFsm_4
//  405         {
//  406 //            uint16_t uiData = CAdc::GetMeasureValue();
//  407 //            axChipsChannelsData[MASTER_CHIP_ADDRESS].axMeasurementChannels[m_uiChannel].m_uiState =
//  408 //                CMeasurementChannel::StatusCheck(CAdc::GetMeasureValue());
//  409 
//  410             uint8_t uiState =
//  411                 CMeasurementChannel::StatusCheck(CAdc::GetMeasureValue());
        RCALL   ??GetMeasureValue
        RCALL   ??StatusCheck
        MOV     R24, R16
//  412             m_aucRtuDiscreteInputsArray[m_uiChannel * 2] = (uiState & 0x01);
        MOV     R18, R24
        ANDI    R18, 0x01
        LDS     R16, ??m_uiChannel
        LDI     R17, 0
        LSL     R16
        ROL     R17
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_aucRtuDiscreteInputsArray) & 0xFFFF))
        SBCI    R31, (-(??m_aucRtuDiscreteInputsArray) & 0xFFFF) >> 8
        ST      Z, R18
//  413             m_aucRtuDiscreteInputsArray[(m_uiChannel * 2) + 1] = ((uiState >> 1) & 0x01);
        MOV     R18, R24
        BST     R18, 1
        LDI     R18, 0
        BLD     R18, 0
        LDS     R16, ??m_uiChannel
        LDI     R17, 0
        LSL     R16
        ROL     R17
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_aucRtuDiscreteInputsArray) & 0xFFFF))
        SBCI    R31, (-(??m_aucRtuDiscreteInputsArray) & 0xFFFF) >> 8
        STD     Z+1, R18
//  414 
//  415             m_uiChannel++;
        LDS     R16, ??m_uiChannel
        INC     R16
        STS     ??m_uiChannel, R16
//  416             if (m_uiChannel < MEASURE_CHANNEL_NUMBER)
        LDS     R16, ??m_uiChannel
        CPI     R16, 8
        BRCC    ??MeasureFsm_5
//  417             {
//  418                 CAdc::Stop();
        RCALL   ??Stop
//  419                 CAdc::ChannelSelect(m_uiChannel);
        LDS     R16, ??m_uiChannel
        RCALL   ??ChannelSelect
//  420                 CAdc::Start();
        RCALL   ??Start
        RJMP    ??MeasureFsm_4
//  421             }
//  422             else
//  423             {
//  424                 CAdc::Disable();
??MeasureFsm_5:
        RCALL   ??Disable
//  425 //                ChannelsToDiscreteInput();
//  426                 m_uiMeasureFlowControl = FSM_IDDLE;
        LDI     R16, 0
        STS     ??m_uiMeasureFlowControl, R16
//  427             }
//  428         }
//  429         break;
//  430 
//  431     default:
//  432         break;
//  433     }
//  434 }
??MeasureFsm_4:
        LD      R24, Y+
        RET

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,020H
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,021H
__?EEARL:

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DC16    0
        REQUIRE ?need_segment_init

        RSEG NEAR_F:CODE:ROOT(0)
        DC8 0, 0

        END
//  435 
//  436 
//  437 
//  438 
//  439 
//  440 
//  441 
//  442 ////-----------------------------------------------------------------------------------------------------
//  443 //CMvsn21Driver::CMvsn21Driver(uint8_t uiType) :
//  444 //
//  445 //    m_uiType(uiType),
//  446 //{
//  447 //
//  448 //}
//  449 //
//  450 ////-----------------------------------------------------------------------------------------------------
//  451 //CMvsn21Driver::~CMvsn21Driver()
//  452 //{
//  453 //
//  454 //}
//  455 //
//  456 ////-----------------------------------------------------------------------------------------------------
//  457 //uint16_t CMvsn21Driver::TypeReport(uint8_t *puiDestination, uint16_t uiLength)
//  458 //{
//  459 //
//  460 //}
// 
//  87 bytes in segment ABSOLUTE
// 176 bytes in segment CODE
//   6 bytes in segment INITTAB
//   2 bytes in segment NEAR_F
// 126 bytes in segment NEAR_Z
// 
// 150 bytes of CODE memory (+ 34 bytes shared)
// 126 bytes of DATA memory (+ 87 bytes shared)
//
//Errors: none
//Warnings: 6
