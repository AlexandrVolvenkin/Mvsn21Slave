///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.10.6.1378 for Atmel AVR          08/May/2022  01:33:49
// Copyright 1996-2018 IAR Systems AB.
//
//    Source file  =  
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\src\Platform.cpp
//    Command line =  
//        -f C:\Users\ghost\AppData\Local\Temp\EW2E3F.tmp
//        (--string_literals_in_flash
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\src\Platform.cpp
//        --cpu=m48 -ms -o
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Debug\Obj -lB
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Debug\List
//        --initializers_in_flash --root_variables --no_cse --no_inline
//        --no_code_motion --no_cross_call --no_clustering --no_tbaa --debug
//        -DENABLE_BIT_DEFINITIONS -e -I
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\include\ -I
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Modbus\ --eeprom_size
//        256 --dlib --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 8.0\avr\LIB\DLIB\dlAVR-1s-ec_mul-n.h" -On --eec++)
//    Locale       =  Russian_RUS.1251
//    List file    =  
//        D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\Debug\List\Platform.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME Platform

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        ERROR
//NOTE: This module defines or uses C++ features that are not
//      accessible from assembler code. Assembling this file will
//      not produce an equivalent object file to the one produced
//      by the C++ compiler.

        EXTERN ?EPILOGUE_B11_L09
        EXTERN ?EPILOGUE_B2_L09
        EXTERN ?EPILOGUE_B4_L09
        EXTERN ?EPILOGUE_B6_L09
        EXTERN ?L_EC_MUL_L03
        EXTERN ?PROLOGUE11_L09
        EXTERN ?PROLOGUE2_L09
        EXTERN ?PROLOGUE4_L09
        EXTERN ?PROLOGUE6_L09
        EXTERN ?Register_R10_is_cg_reg
        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?Register_R5_is_cg_reg
        EXTERN ?Register_R6_is_cg_reg
        EXTERN ?Register_R7_is_cg_reg
        EXTERN ?Register_R8_is_cg_reg
        EXTERN ?Register_R9_is_cg_reg
        EXTERN ?UL_DIVMOD_L03
        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBLIC ??ChannelSelect
        PUBLIC ??Disable
        PUBLIC ??Disable_1
        PUBLIC ??Enable
        PUBLIC ??Enable_1
        PUBLIC ??GetMeasureValue
        PUBWEAK ??IncrementSystemTick
        PUBLIC ??Init
        PUBLIC ??Init_1
        PUBLIC ??Init_2
        PUBWEAK ??InterruptDisable
        PUBWEAK ??InterruptEnable
        PUBWEAK ??MeasureFlowControlSet
        PUBLIC ??Read
        PUBLIC ??ReadByte
        PUBLIC ??Read_1
        PUBLIC ??RecvInterruptHandler
        PUBLIC ??Reset
        PUBLIC ??SIG_UART0_DATA
        PUBWEAK `??SIG_UART0_DATA::??INTVEC 38`
        PUBLIC ??SIG_UART0_RECV
        PUBWEAK `??SIG_UART0_RECV::??INTVEC 36`
        PUBLIC ??SIG_UART0_TXC
        PUBWEAK `??SIG_UART0_TXC::??INTVEC 40`
        PUBLIC ??Start
        PUBLIC ??StartSingle
        PUBLIC ??Stop
        PUBLIC ??SystemTickInit
        PUBLIC ??SystemTickInterrupt
        PUBWEAK `??SystemTickInterrupt::??INTVEC 14`
        PUBLIC ??TxcInterruptHandler
        PUBLIC ??UartBind
        PUBLIC ??UdreInterruptHandler
        PUBLIC ??Write
        PUBLIC ??WriteByte
        PUBLIC ??Write_1
        PUBLIC ??m_UBRRH
        PUBLIC ??m_UBRRL
        PUBLIC ??m_UCSRA
        PUBLIC ??m_UCSRB
        PUBLIC ??m_UCSRC
        PUBLIC ??m_UDR
        PUBLIC ??m_auiIntermediateBuff
        PUBLIC ??m_bfByteIsReceived
        PUBLIC ??m_bfFrameIsSended
        PUBLIC ??m_bfRxBuffOverflow
        PUBLIC ??m_fbMeasureIsComlete
        PUBLIC ??m_nuiRxBuffByteCounter
        PUBLIC ??m_nuiTxBuffByteCounter
        PUBLIC ??m_puiRxBuffer
        PUBLIC ??m_puiTxBuffer
        PUBLIC ??m_pxUart0
        PUBLIC ??m_pxUart1
        PUBLIC ??m_rs485ddpin
        PUBLIC ??m_rs485ddr
        PUBLIC ??m_rs485pin
        PUBLIC ??m_rs485port
        PUBLIC ??m_uiSystemTick
        PUBLIC ??uiSlaveSelectIsHigh
        PUBWEAK _A_ACSR
        PUBWEAK _A_ADC
        PUBWEAK _A_ADCSRA
        PUBWEAK _A_ADCSRB
        PUBWEAK _A_ADMUX
        PUBWEAK _A_ASSR
        PUBWEAK _A_CLKPR
        PUBWEAK _A_DDRB
        PUBWEAK _A_DDRC
        PUBWEAK _A_DDRD
        PUBWEAK _A_DIDR0
        PUBWEAK _A_DIDR1
        PUBWEAK _A_EEAR
        PUBWEAK _A_EECR
        PUBWEAK _A_EEDR
        PUBWEAK _A_EICRA
        PUBWEAK _A_EIFR
        PUBWEAK _A_EIMSK
        PUBWEAK _A_GPIOR0
        PUBWEAK _A_GPIOR1
        PUBWEAK _A_GPIOR2
        PUBWEAK _A_GTCCR
        PUBWEAK _A_ICR1
        PUBWEAK _A_MCUCR
        PUBWEAK _A_MCUSR
        PUBWEAK _A_OCR0A
        PUBWEAK _A_OCR0B
        PUBWEAK _A_OCR1A
        PUBWEAK _A_OCR1B
        PUBWEAK _A_OCR2A
        PUBWEAK _A_OCR2B
        PUBWEAK _A_OSCCAL
        PUBWEAK _A_PCICR
        PUBWEAK _A_PCIFR
        PUBWEAK _A_PCMSK0
        PUBWEAK _A_PCMSK1
        PUBWEAK _A_PCMSK2
        PUBWEAK _A_PINB
        PUBWEAK _A_PINC
        PUBWEAK _A_PIND
        PUBWEAK _A_PORTB
        PUBWEAK _A_PORTC
        PUBWEAK _A_PORTD
        PUBWEAK _A_PRR
        PUBWEAK _A_SMCR
        PUBWEAK _A_SP
        PUBWEAK _A_SPCR
        PUBWEAK _A_SPDR
        PUBWEAK _A_SPMCSR
        PUBWEAK _A_SPSR
        PUBWEAK _A_SREG
        PUBWEAK _A_TCCR0A
        PUBWEAK _A_TCCR0B
        PUBWEAK _A_TCCR1A
        PUBWEAK _A_TCCR1B
        PUBWEAK _A_TCCR1C
        PUBWEAK _A_TCCR2A
        PUBWEAK _A_TCCR2B
        PUBWEAK _A_TCNT0
        PUBWEAK _A_TCNT1
        PUBWEAK _A_TCNT2
        PUBWEAK _A_TIFR0
        PUBWEAK _A_TIFR1
        PUBWEAK _A_TIFR2
        PUBWEAK _A_TIMSK0
        PUBWEAK _A_TIMSK1
        PUBWEAK _A_TIMSK2
        PUBWEAK _A_TWAMR
        PUBWEAK _A_TWAR
        PUBWEAK _A_TWBR
        PUBWEAK _A_TWCR
        PUBWEAK _A_TWDR
        PUBWEAK _A_TWSR
        PUBWEAK _A_UBRR0
        PUBWEAK _A_UCSR0A
        PUBWEAK _A_UCSR0B
        PUBWEAK _A_UCSR0C
        PUBWEAK _A_UDR0
        PUBWEAK _A_WDTCSR
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR

`?<Name CMvsn21 0>` SYMBOL "CMvsn21"
??m_uiMeasureFlowControl SYMBOL "m_uiMeasureFlowControl", `?<Name CMvsn21 0>`
`?<Name CAdc 2>`    SYMBOL "CAdc"
`?<Name CUart 8>`   SYMBOL "CUart"
`?<Name CPlatform 18>` SYMBOL "CPlatform"

`??SIG_UART0_DATA::??INTVEC 38` SYMBOL "??INTVEC 38", ??SIG_UART0_DATA

`??SIG_UART0_RECV::??INTVEC 36` SYMBOL "??INTVEC 36", ??SIG_UART0_RECV

`??SIG_UART0_TXC::??INTVEC 40` SYMBOL "??INTVEC 40", ??SIG_UART0_TXC

`??SystemTickInterrupt::??INTVEC 14` SYMBOL "??INTVEC 14", ??SystemTickInterrupt
??m_UBRRH           SYMBOL "m_UBRRH", `?<Name CUart 8>`
??m_UBRRL           SYMBOL "m_UBRRL", `?<Name CUart 8>`
??m_UCSRA           SYMBOL "m_UCSRA", `?<Name CUart 8>`
??m_UCSRB           SYMBOL "m_UCSRB", `?<Name CUart 8>`
??m_UCSRC           SYMBOL "m_UCSRC", `?<Name CUart 8>`
??m_UDR             SYMBOL "m_UDR", `?<Name CUart 8>`
??m_auiIntermediateBuff SYMBOL "m_auiIntermediateBuff", `?<Name CUart 8>`
??m_bfByteIsReceived SYMBOL "m_bfByteIsReceived", `?<Name CUart 8>`
??m_bfFrameIsSended SYMBOL "m_bfFrameIsSended", `?<Name CUart 8>`
??m_bfRxBuffOverflow SYMBOL "m_bfRxBuffOverflow", `?<Name CUart 8>`
??m_fbMeasureIsComlete SYMBOL "m_fbMeasureIsComlete", `?<Name CAdc 2>`
??m_nuiRxBuffByteCounter SYMBOL "m_nuiRxBuffByteCounter", `?<Name CUart 8>`
??m_nuiTxBuffByteCounter SYMBOL "m_nuiTxBuffByteCounter", `?<Name CUart 8>`
??m_puiRxBuffer     SYMBOL "m_puiRxBuffer", `?<Name CUart 8>`
??m_puiTxBuffer     SYMBOL "m_puiTxBuffer", `?<Name CUart 8>`
??m_pxUart0         SYMBOL "m_pxUart0", `?<Name CPlatform 18>`
??m_pxUart1         SYMBOL "m_pxUart1", `?<Name CPlatform 18>`
??m_rs485ddpin      SYMBOL "m_rs485ddpin", `?<Name CUart 8>`
??m_rs485ddr        SYMBOL "m_rs485ddr", `?<Name CUart 8>`
??m_rs485pin        SYMBOL "m_rs485pin", `?<Name CUart 8>`
??m_rs485port       SYMBOL "m_rs485port", `?<Name CUart 8>`
??m_uiSystemTick    SYMBOL "m_uiSystemTick", `?<Name CPlatform 18>`
??uiSlaveSelectIsHigh SYMBOL "uiSlaveSelectIsHigh", `?<Name CPlatform 18>`

        EXTERN ??m_uiMeasureFlowControl

// D:\Projects\CautoProjects\Mvsn21\Mvsn21Slave\src\Platform.cpp
//    1 //-----------------------------------------------------------------------------------------------------
//    2 //  Source      : FileName.cpp
//    3 //  Created     : 01.06.2022
//    4 //  Author      : Alexandr Volvenkin
//    5 //  email       : aav-36@mail.ru
//    6 //  GitHub      : https://github.com/AlexandrVolvenkin
//    7 //-----------------------------------------------------------------------------------------------------
//    8 #include "Platform.h"

        ASEGN ABSOLUTE:DATA:ROOT,0c6H
// union <unnamed> volatile __io _A_UDR0
_A_UDR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c4H
// union <unnamed> volatile __io _A_UBRR0
_A_UBRR0:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,0c2H
// union <unnamed> volatile __io _A_UCSR0C
_A_UCSR0C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c1H
// union <unnamed> volatile __io _A_UCSR0B
_A_UCSR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0c0H
// union <unnamed> volatile __io _A_UCSR0A
_A_UCSR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bdH
// union <unnamed> volatile __io _A_TWAMR
_A_TWAMR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bcH
// union <unnamed> volatile __io _A_TWCR
_A_TWCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0bbH
// union <unnamed> volatile __io _A_TWDR
_A_TWDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0baH
// union <unnamed> volatile __io _A_TWAR
_A_TWAR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b9H
// union <unnamed> volatile __io _A_TWSR
_A_TWSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b8H
// union <unnamed> volatile __io _A_TWBR
_A_TWBR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b6H
// union <unnamed> volatile __io _A_ASSR
_A_ASSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b4H
// union <unnamed> volatile __io _A_OCR2B
_A_OCR2B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b3H
// union <unnamed> volatile __io _A_OCR2A
_A_OCR2A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b2H
// union <unnamed> volatile __io _A_TCNT2
_A_TCNT2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b1H
// union <unnamed> volatile __io _A_TCCR2B
_A_TCCR2B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,0b0H
// union <unnamed> volatile __io _A_TCCR2A
_A_TCCR2A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,08aH
// union <unnamed> volatile __io _A_OCR1B
_A_OCR1B:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,088H
// union <unnamed> volatile __io _A_OCR1A
_A_OCR1A:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,086H
// union <unnamed> volatile __io _A_ICR1
_A_ICR1:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,084H
// union <unnamed> volatile __io _A_TCNT1
_A_TCNT1:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,082H
// union <unnamed> volatile __io _A_TCCR1C
_A_TCCR1C:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,081H
// union <unnamed> volatile __io _A_TCCR1B
_A_TCCR1B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,080H
// union <unnamed> volatile __io _A_TCCR1A
_A_TCCR1A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07fH
// union <unnamed> volatile __io _A_DIDR1
_A_DIDR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07eH
// union <unnamed> volatile __io _A_DIDR0
_A_DIDR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07cH
// union <unnamed> volatile __io _A_ADMUX
_A_ADMUX:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07bH
// union <unnamed> volatile __io _A_ADCSRB
_A_ADCSRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,07aH
// union <unnamed> volatile __io _A_ADCSRA
_A_ADCSRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,078H
// union <unnamed> volatile __io _A_ADC
_A_ADC:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,070H
// union <unnamed> volatile __io _A_TIMSK2
_A_TIMSK2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06fH
// union <unnamed> volatile __io _A_TIMSK1
_A_TIMSK1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06eH
// union <unnamed> volatile __io _A_TIMSK0
_A_TIMSK0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06dH
// union <unnamed> volatile __io _A_PCMSK2
_A_PCMSK2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06cH
// union <unnamed> volatile __io _A_PCMSK1
_A_PCMSK1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,06bH
// union <unnamed> volatile __io _A_PCMSK0
_A_PCMSK0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,069H
// union <unnamed> volatile __io _A_EICRA
_A_EICRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,068H
// union <unnamed> volatile __io _A_PCICR
_A_PCICR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,066H
// union <unnamed> volatile __io _A_OSCCAL
_A_OSCCAL:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,064H
// union <unnamed> volatile __io _A_PRR
_A_PRR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,061H
// union <unnamed> volatile __io _A_CLKPR
_A_CLKPR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,060H
// union <unnamed> volatile __io _A_WDTCSR
_A_WDTCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05fH
// union <unnamed> volatile __io _A_SREG
_A_SREG:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,05dH
// union <unnamed> volatile __io _A_SP
_A_SP:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,057H
// union <unnamed> volatile __io _A_SPMCSR
_A_SPMCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,055H
// union <unnamed> volatile __io _A_MCUCR
_A_MCUCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,054H
// union <unnamed> volatile __io _A_MCUSR
_A_MCUSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,053H
// union <unnamed> volatile __io _A_SMCR
_A_SMCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,050H
// union <unnamed> volatile __io _A_ACSR
_A_ACSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04eH
// union <unnamed> volatile __io _A_SPDR
_A_SPDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04dH
// union <unnamed> volatile __io _A_SPSR
_A_SPSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04cH
// union <unnamed> volatile __io _A_SPCR
_A_SPCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04bH
// union <unnamed> volatile __io _A_GPIOR2
_A_GPIOR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,04aH
// union <unnamed> volatile __io _A_GPIOR1
_A_GPIOR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,048H
// union <unnamed> volatile __io _A_OCR0B
_A_OCR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,047H
// union <unnamed> volatile __io _A_OCR0A
_A_OCR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,046H
// union <unnamed> volatile __io _A_TCNT0
_A_TCNT0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,045H
// union <unnamed> volatile __io _A_TCCR0B
_A_TCCR0B:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,044H
// union <unnamed> volatile __io _A_TCCR0A
_A_TCCR0A:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,043H
// union <unnamed> volatile __io _A_GTCCR
_A_GTCCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,041H
// union <unnamed> volatile __io _A_EEAR
_A_EEAR:
        DS8 2

        ASEGN ABSOLUTE:DATA:ROOT,040H
// union <unnamed> volatile __io _A_EEDR
_A_EEDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03fH
// union <unnamed> volatile __io _A_EECR
_A_EECR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03eH
// union <unnamed> volatile __io _A_GPIOR0
_A_GPIOR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03dH
// union <unnamed> volatile __io _A_EIMSK
_A_EIMSK:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03cH
// union <unnamed> volatile __io _A_EIFR
_A_EIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,03bH
// union <unnamed> volatile __io _A_PCIFR
_A_PCIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,037H
// union <unnamed> volatile __io _A_TIFR2
_A_TIFR2:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,036H
// union <unnamed> volatile __io _A_TIFR1
_A_TIFR1:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,035H
// union <unnamed> volatile __io _A_TIFR0
_A_TIFR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02bH
// union <unnamed> volatile __io _A_PORTD
_A_PORTD:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,02aH
// union <unnamed> volatile __io _A_DDRD
_A_DDRD:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,029H
// union <unnamed> volatile __io _A_PIND
_A_PIND:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,028H
// union <unnamed> volatile __io _A_PORTC
_A_PORTC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,027H
// union <unnamed> volatile __io _A_DDRC
_A_DDRC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,026H
// union <unnamed> volatile __io _A_PINC
_A_PINC:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,025H
// union <unnamed> volatile __io _A_PORTB
_A_PORTB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,024H
// union <unnamed> volatile __io _A_DDRB
_A_DDRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:ROOT,023H
// union <unnamed> volatile __io _A_PINB
_A_PINB:
        DS8 1

        RSEG CODE:CODE:NOROOT(1)
// __version_3 void CPlatform::InterruptEnable()
??InterruptEnable:
        SEI
        RET

        RSEG CODE:CODE:NOROOT(1)
// __version_3 void CPlatform::InterruptDisable()
??InterruptDisable:
        CLI
        RET

        RSEG CODE:CODE:NOROOT(1)
// __version_3 void CPlatform::IncrementSystemTick()
??IncrementSystemTick:
        LDI     R30, LOW(??m_uiSystemTick)
        LDI     R31, (??m_uiSystemTick) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        SUBI    R16, 255
        SBCI    R17, 255
        ST      Z, R16
        STD     Z+1, R17
        RET
//    9 #include "Mvsn21.h"

        RSEG CODE:CODE:NOROOT(1)
// __version_3 void CMvsn21::MeasureFlowControlSet(uint8_t)
??MeasureFlowControlSet:
        STS     ??m_uiMeasureFlowControl, R16
        RET
//   10 
//   11 // ATMega48
//   12 

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   13 bool CAdc::m_fbMeasureIsComlete;
??m_fbMeasureIsComlete:
        DS8 1
//   14 ////-----------------------------------------------------------------------------------------------------
//   15 //CAdc::CAdc()
//   16 //{
//   17 //
//   18 //}
//   19 //
//   20 ////-----------------------------------------------------------------------------------------------------
//   21 //CAdc::~CAdc()
//   22 //{
//   23 //
//   24 //}
//   25 
//   26 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   27 void CAdc::Init(void)
??Init:
//   28 {
//   29     // Отключаем цифровые входные буферы на линиях АЦП.
//   30     DIDR0  = 0x3F;
        LDI     R16, 63
        STS     _A_DIDR0, R16
//   31     // SCK/128
//   32     ADCSRA = CAdc::DIV128;
        LDI     R16, 7
        STS     _A_ADCSRA, R16
//   33     ADCSRB = 0x00;
        LDI     R16, 0
        STS     _A_ADCSRB, R16
//   34     // Внутренний источник опорного напряжения Vref = 1.1V
//   35     ADMUX = (BIT(REFS1) | BIT(REFS0));
        LDI     R16, 192
        STS     _A_ADMUX, R16
//   36 }
        RET
        REQUIRE _A_DIDR0
        REQUIRE _A_ADCSRA
        REQUIRE _A_ADCSRB
        REQUIRE _A_ADMUX
//   37 
//   38 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   39 void CAdc::ChannelSelect(uint8_t uiChannel)
??ChannelSelect:
//   40 {
//   41     ADMUX &= ~(0x0F);
        LDS     R17, _A_ADMUX
        ANDI    R17, 0xF0
        STS     _A_ADMUX, R17
//   42     ADMUX |= (uiChannel & 0x0F);
        MOV     R17, R16
        ANDI    R17, 0x0F
        LDS     R18, _A_ADMUX
        OR      R18, R17
        STS     _A_ADMUX, R18
//   43 }
        RET
        REQUIRE _A_ADMUX
//   44 
//   45 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   46 void CAdc::StartSingle(void)
??StartSingle:
//   47 {
//   48     // Отключаем режим пониженного энергопотребления.
//   49     PRR &= ~BIT(PRADC);
        LDS     R16, 100
        ANDI    R16, 0xFE
        STS     100, R16
//   50     // Включаем АЦП.
//   51     ADCSRA |= (BIT(ADEN) | BIT(ADIE) | BIT(ADSC));
        LDS     R16, _A_ADCSRA
        ORI     R16, 0xC8
        STS     _A_ADCSRA, R16
//   52 }
        RET
        REQUIRE _A_PRR
        REQUIRE _A_ADCSRA
//   53 
//   54 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   55 void CAdc::Start(void)
??Start:
//   56 {
//   57     // Включаем АЦП.
//   58 ////    ADCSRA |= (BIT(ADEN) | BIT(ADIE) | BIT(ADSC));
//   59     ADCSRA |= (BIT(ADEN) | BIT(ADSC));
        LDS     R16, _A_ADCSRA
        ORI     R16, 0xC0
        STS     _A_ADCSRA, R16
//   60 //    ADCSRA |= (BIT(ADSC));
//   61 }
        RET
        REQUIRE _A_ADCSRA
//   62 
//   63 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   64 void CAdc::Stop(void)
??Stop:
//   65 {
//   66     // Выключаем АЦП.
//   67     ADCSRA &= ~(BIT(ADEN) | BIT(ADSC));
        LDS     R16, _A_ADCSRA
        ANDI    R16, 0x3F
        STS     _A_ADCSRA, R16
//   68 //    ADCSRA &= ~(BIT(ADEN) | BIT(ADIE) | BIT(ADSC));
//   69 }
        RET
        REQUIRE _A_ADCSRA
//   70 
//   71 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   72 void CAdc::Disable(void)
??Disable:
//   73 {
//   74     // Выключаем АЦП.
//   75 //    ADCSRA &= ~(BIT(ADEN) | BIT(ADIE) | BIT(ADSC));
//   76     ADCSRA &= ~(BIT(ADEN) | BIT(ADSC));
        LDS     R16, _A_ADCSRA
        ANDI    R16, 0x3F
        STS     _A_ADCSRA, R16
//   77     // Включаем режим пониженного энергопотребления.
//   78     PRR |= BIT(PRADC);
        LDS     R16, 100
        ORI     R16, 0x01
        STS     100, R16
//   79 }
        RET
        REQUIRE _A_ADCSRA
        REQUIRE _A_PRR
//   80 
//   81 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   82 void CAdc::Enable(void)
??Enable:
//   83 {
//   84     // Отключаем режим пониженного энергопотребления.
//   85     PRR &= ~BIT(PRADC);
        LDS     R16, 100
        ANDI    R16, 0xFE
        STS     100, R16
//   86     // Включаем АЦП.
//   87 //    ADCSRA |= (BIT(ADEN) | BIT(ADIE));
//   88     ADCSRA |= BIT(ADEN);
        LDS     R16, 122
        ORI     R16, 0x80
        STS     122, R16
//   89 }
        RET
        REQUIRE _A_PRR
        REQUIRE _A_ADCSRA
//   90 
//   91 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//   92 uint16_t CAdc::GetMeasureValue(void)
??GetMeasureValue:
//   93 {
//   94     uint16_t uiData;
//   95     uiData = (static_cast<uint16_t>(ADCL));
        LDS     R18, _A_ADC
        LDI     R19, 0
        MOVW    R17:R16, R19:R18
//   96     uiData |= (static_cast<uint16_t>(ADCH) << 8);
        LDS     R19, 121
        LDI     R18, 0
        OR      R16, R18
        OR      R17, R19
//   97     return uiData;
        RET
        REQUIRE _A_ADC
//   98 };
//   99 
//  100 ////-----------------------------------------------------------------------------------------------------
//  101 //#pragma vector = ADC_vect
//  102 //__interrupt void CAdc::SIG_ADC(void)
//  103 //{
//  104 //    m_fbMeasureIsComlete = true;
//  105 //}
//  106 ////-----------------------------------------------------------------------------------------------------
//  107 
//  108 
//  109 
//  110 
//  111 

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  112 volatile uint8_t* CUart::m_UBRRH;
??m_UBRRH:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  113 volatile uint8_t* CUart::m_UBRRL;
??m_UBRRL:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  114 volatile uint8_t* CUart::m_UCSRA;
??m_UCSRA:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  115 volatile uint8_t* CUart::m_UCSRB;
??m_UCSRB:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  116 volatile uint8_t* CUart::m_UCSRC;
??m_UCSRC:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  117 volatile uint8_t* CUart::m_UDR;
??m_UDR:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  118 volatile uint8_t* CUart::m_rs485ddr;
??m_rs485ddr:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  119 volatile uint8_t CUart::m_rs485ddpin;
??m_rs485ddpin:
        DS8 1

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  120 volatile uint8_t* CUart::m_rs485port;
??m_rs485port:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  121 volatile uint8_t CUart::m_rs485pin;
??m_rs485pin:
        DS8 1
//  122 

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  123 uint8_t* CUart::m_puiTxBuffer;
??m_puiTxBuffer:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  124 uint16_t CUart::m_nuiTxBuffByteCounter;
??m_nuiTxBuffByteCounter:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  125 uint8_t* CUart::m_puiRxBuffer;
??m_puiRxBuffer:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  126 uint16_t CUart::m_nuiRxBuffByteCounter;
??m_nuiRxBuffByteCounter:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  127 uint8_t CUart::m_auiIntermediateBuff[UART_INTERMEDIATE_BUFF_LENGTH];
??m_auiIntermediateBuff:
        DS8 16

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  128 bool CUart::m_bfByteIsReceived;
??m_bfByteIsReceived:
        DS8 1

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  129 bool CUart::m_bfFrameIsSended;
??m_bfFrameIsSended:
        DS8 1

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  130 bool CUart::m_bfRxBuffOverflow;
??m_bfRxBuffOverflow:
        DS8 1
//  131 
//  132 ////-----------------------------------------------------------------------------------------------------
//  133 //CUart::CUart()
//  134 //{
//  135 //
//  136 //}
//  137 
//  138 ////-----------------------------------------------------------------------------------------------------
//  139 //CUart::CUart(volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
//  140 //             volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
//  141 //             volatile uint8_t *ucsrc, volatile uint8_t *udr,
//  142 //             volatile uint8_t *rs485ddr, volatile uint8_t rs485ddpin,
//  143 //             volatile uint8_t *rs485port, volatile uint8_t rs485pin) :
//  144 //    m_UBRRH(ubrrh), m_UBRRL(ubrrl), m_UCSRA(ucsra),
//  145 //    m_UCSRB(ucsrb), m_UCSRC(ucsrc), m_UDR(udr),
//  146 //    m_rs485ddr(rs485ddr), m_rs485ddpin(rs485ddpin), m_rs485port(rs485port), m_rs485pin(rs485pin)
//  147 //{
//  148 //    if (m_rs485ddr)
//  149 //    {
//  150 //        *m_rs485ddr |= Bit(m_rs485ddpin);
//  151 //        *m_rs485port &= ~(Bit(m_rs485pin));
//  152 //    }
//  153 //}
//  154 
//  155 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  156 void CUart::UartBind(volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
??UartBind:
//  157                      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
//  158                      volatile uint8_t *ucsrc, volatile uint8_t *udr,
//  159                      volatile uint8_t *rs485ddr, volatile uint8_t rs485ddpin,
//  160                      volatile uint8_t *rs485port, volatile uint8_t rs485pin)
//  161 {
        LD      R0, Y
        LDD     R1, Y+1
        LDD     R2, Y+2
        LDD     R3, Y+3
//  162     m_UBRRH = ubrrh;
        LDI     R30, LOW(??m_UBRRH)
        LDI     R31, (??m_UBRRH) >> 8
        ST      Z, R16
        STD     Z+1, R17
//  163     m_UBRRL = ubrrl;
        LDI     R30, LOW(??m_UBRRL)
        LDI     R31, (??m_UBRRL) >> 8
        ST      Z, R18
        STD     Z+1, R19
//  164     m_UCSRA = ucsra;
        LDI     R30, LOW(??m_UCSRA)
        LDI     R31, (??m_UCSRA) >> 8
        ST      Z, R20
        STD     Z+1, R21
//  165     m_UCSRB = ucsrb;
        LDI     R30, LOW(??m_UCSRB)
        LDI     R31, (??m_UCSRB) >> 8
        ST      Z, R22
        STD     Z+1, R23
//  166     m_UCSRC = ucsrc;
        LDI     R30, LOW(??m_UCSRC)
        LDI     R31, (??m_UCSRC) >> 8
        ST      Z, R0
        STD     Z+1, R1
//  167     m_UDR = udr;
        LDI     R30, LOW(??m_UDR)
        LDI     R31, (??m_UDR) >> 8
        ST      Z, R2
        STD     Z+1, R3
//  168 //    m_rs485ddr = rs485ddr;
//  169 //    m_rs485ddpin = rs485ddpin;
//  170 //    m_rs485port = rs485port;
//  171 //    m_rs485pin = rs485pin;
//  172 //
//  173 //    if (m_rs485ddr)
//  174 //    {
//  175 //        *m_rs485ddr |= Bit(m_rs485ddpin);
//  176 //        *m_rs485port &= ~(Bit(m_rs485pin));
//  177 //    }
//  178 }
        ADIW    R29:R28, 10
        RET
//  179 
//  180 ////-----------------------------------------------------------------------------------------------------
//  181 //CUart::~CUart()
//  182 //{
//  183 //
//  184 //}
//  185 
//  186 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  187 void CUart::Init(uint32_t ulBaudRate,
??Init_1:
//  188                  uint8_t ucParity,
//  189                  uint8_t ucDataBits,
//  190                  uint8_t ucStopBit,
//  191                  uint8_t *puiRxBuffer,
//  192                  uint8_t *puiTxBuffer)
//  193 {
        RCALL   ?PROLOGUE11_L09
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R7_is_cg_reg
        REQUIRE ?Register_R8_is_cg_reg
        REQUIRE ?Register_R9_is_cg_reg
        REQUIRE ?Register_R10_is_cg_reg
        MOVW    R25:R24, R17:R16
        MOVW    R27:R26, R19:R18
        MOV     R9, R20
        MOV     R10, R21
        MOV     R8, R22
        LDD     R6, Y+11
        LDD     R7, Y+12
        LDD     R4, Y+13
        LDD     R5, Y+14
//  194     m_puiRxBuffer = puiRxBuffer;
        LDI     R30, LOW(??m_puiRxBuffer)
        LDI     R31, (??m_puiRxBuffer) >> 8
        ST      Z, R6
        STD     Z+1, R7
//  195     m_puiTxBuffer = puiTxBuffer;
        LDI     R30, LOW(??m_puiTxBuffer)
        LDI     R31, (??m_puiTxBuffer) >> 8
        ST      Z, R4
        STD     Z+1, R5
//  196 
//  197     /* Set the baud rate */
//  198     uint16_t uiBaudRateTemp = (F_CPU / (ulBaudRate * 16UL) - 1);
        MOVW    R17:R16, R25:R24
        MOVW    R19:R18, R27:R26
        LDI     R20, 16
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
        RCALL   ?L_EC_MUL_L03
        MOVW    R21:R20, R17:R16
        MOVW    R23:R22, R19:R18
        LDI     R16, 0
        LDI     R17, 128
        LDI     R18, 112
        LDI     R19, 0
        RCALL   ?UL_DIVMOD_L03
        MOVW    R21:R20, R17:R16
        SUBI    R20, 1
        SBCI    R21, 0
//  199     *m_UBRRL = uiBaudRateTemp;
        MOV     R18, R20
        LDI     R30, LOW(??m_UBRRL)
        LDI     R31, (??m_UBRRL) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        MOVW    R31:R30, R17:R16
        ST      Z, R18
//  200     *m_UBRRH = (uiBaudRateTemp >> 8);
        MOVW    R17:R16, R21:R20
        MOV     R16, R17
        LDI     R17, 0
        MOV     R18, R16
        LDI     R30, LOW(??m_UBRRH)
        LDI     R31, (??m_UBRRH) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        MOVW    R31:R30, R17:R16
        ST      Z, R18
//  201 
//  202     /* Set data bits (7, 8 bits) */
//  203     switch (ucDataBits)
        MOV     R16, R10
        SUBI    R16, 7
        BREQ    ??Init_3
        DEC     R16
        BRNE    ??Init_4
//  204     {
//  205     case 8:
//  206         *m_UCSRC |= (1 << UCSZ00) | (1 << UCSZ01);
        LDI     R30, LOW(??m_UCSRC)
        LDI     R31, (??m_UCSRC) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        MOVW    R31:R30, R17:R16
        LD      R16, Z
        ORI     R16, 0x06
        ST      Z, R16
//  207         break;
        RJMP    ??Init_4
//  208     case 7:
//  209         *m_UCSRC |= (1 << UCSZ01);
??Init_3:
        LDI     R30, LOW(??m_UCSRC)
        LDI     R31, (??m_UCSRC) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        MOVW    R31:R30, R17:R16
        LD      R16, Z
        ORI     R16, 0x04
        ST      Z, R16
//  210         break;
//  211     }
//  212 
//  213     /* Set parity */
//  214     if (ucParity == 'N')
??Init_4:
        LDI     R16, 78
        CP      R9, R16
        BREQ    ??Init_5
//  215     {
//  216         /* None */
//  217     }
//  218     else if (ucParity == 'E')
        LDI     R16, 69
        CP      R9, R16
        BRNE    ??Init_6
//  219     {
//  220         /* Even */
//  221         *m_UCSRC |= (1 << UPM01);
        LDI     R30, LOW(??m_UCSRC)
        LDI     R31, (??m_UCSRC) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        MOVW    R31:R30, R17:R16
        LD      R16, Z
        ORI     R16, 0x20
        ST      Z, R16
        RJMP    ??Init_5
//  222     }
//  223     else
//  224     {
//  225         /* Odd */
//  226         *m_UCSRC |= (1 << UPM01) | (1 << UPM00);
??Init_6:
        LDI     R30, LOW(??m_UCSRC)
        LDI     R31, (??m_UCSRC) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        MOVW    R31:R30, R17:R16
        LD      R16, Z
        ORI     R16, 0x30
        ST      Z, R16
//  227     }
//  228 
//  229     /* Stop bit (1 or 2) */
//  230     if (ucStopBit == 1)
??Init_5:
        LDI     R16, 1
        CP      R8, R16
        BREQ    ??Init_7
//  231     {
//  232 
//  233     }
//  234     else if (ucStopBit == 2) /* 2 */
        LDI     R16, 2
        CP      R8, R16
        BRNE    ??Init_7
//  235     {
//  236         *m_UCSRC |= (1 << USBS0);
        LDI     R30, LOW(??m_UCSRC)
        LDI     R31, (??m_UCSRC) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        MOVW    R31:R30, R17:R16
        LD      R16, Z
        ORI     R16, 0x08
        ST      Z, R16
//  237     }
//  238 }
??Init_7:
        LDI     R30, 15
        RJMP    ?EPILOGUE_B11_L09
//  239 
//  240 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  241 void CUart::Reset(void)
??Reset:
//  242 {
//  243     m_nuiRxBuffByteCounter = 0;
        LDI     R30, LOW(??m_nuiRxBuffByteCounter)
        LDI     R31, (??m_nuiRxBuffByteCounter) >> 8
        LDI     R16, 0
        ST      Z, R16
        LDI     R16, 0
        STD     Z+1, R16
//  244     m_bfByteIsReceived = 0;
        LDI     R16, 0
        STS     ??m_bfByteIsReceived, R16
//  245     m_bfFrameIsSended = 0;
        LDI     R16, 0
        STS     ??m_bfFrameIsSended, R16
//  246     m_bfRxBuffOverflow = 0;
        LDI     R16, 0
        STS     ??m_bfRxBuffOverflow, R16
//  247 }
        RET
//  248 
//  249 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  250 void CUart::Enable(void)
??Enable_1:
//  251 {
        RCALL   ?PROLOGUE4_L09
//  252     *m_UCSRA |= (1 << RXC0);
        LDI     R26, LOW(??m_UCSRA)
        LDI     R27, (??m_UCSRA) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        ORI     R16, 0x80
        ST      Z, R16
//  253     *m_UCSRB |= (1 << RXEN0) | (1 << RXCIE0);
        LDI     R26, LOW(??m_UCSRB)
        LDI     R27, (??m_UCSRB) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        ORI     R16, 0x90
        ST      Z, R16
//  254 }
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09
//  255 
//  256 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  257 void CUart::Disable(void)
??Disable_1:
//  258 {
        RCALL   ?PROLOGUE4_L09
//  259     *m_UCSRB &= ~((1 << TXEN0) | (1 << TXCIE0));
        LDI     R26, LOW(??m_UCSRB)
        LDI     R27, (??m_UCSRB) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        ANDI    R16, 0xB7
        ST      Z, R16
//  260     *m_UCSRB &= ~((1 << RXEN0) | (1 << RXCIE0));
        LDI     R26, LOW(??m_UCSRB)
        LDI     R27, (??m_UCSRB) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        ANDI    R16, 0x6F
        ST      Z, R16
//  261 }
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09
//  262 
//  263 ////-----------------------------------------------------------------------------------------------------
//  264 //void CUart::Rs485RtsOn(void)
//  265 //{
//  266 //    *m_rs485port |= (1 << m_rs485pin);
//  267 //}
//  268 //
//  269 ////-----------------------------------------------------------------------------------------------------
//  270 //void CUart::Rs485RtsOff(void)
//  271 //{
//  272 //    *m_rs485port &= ~(1 << m_rs485pin);
//  273 //}
//  274 
//  275 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  276 int16_t CUart::Write(uint8_t *puiSource, uint16_t uiLength)
??Write:
//  277 {
        RCALL   ?PROLOGUE4_L09
        MOVW    R21:R20, R17:R16
//  278     m_puiTxBuffer = (uint8_t*)puiSource;
        LDI     R30, LOW(??m_puiTxBuffer)
        LDI     R31, (??m_puiTxBuffer) >> 8
        ST      Z, R20
        STD     Z+1, R21
//  279     m_nuiTxBuffByteCounter = uiLength;
        LDI     R30, LOW(??m_nuiTxBuffByteCounter)
        LDI     R31, (??m_nuiTxBuffByteCounter) >> 8
        ST      Z, R18
        STD     Z+1, R19
//  280 
//  281     *m_UCSRA &= ~(1 << RXC0);
        LDI     R26, LOW(??m_UCSRA)
        LDI     R27, (??m_UCSRA) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        ANDI    R16, 0x7F
        ST      Z, R16
//  282     *m_UCSRB &= ~((1 << RXEN0) | (1 << RXCIE0));
        LDI     R26, LOW(??m_UCSRB)
        LDI     R27, (??m_UCSRB) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        ANDI    R16, 0x6F
        ST      Z, R16
//  283 
//  284 //    if (m_rs485ddr)
//  285 //    {
//  286 //        Rs485RtsOn();
//  287 //    }
//  288 //    UDR0 = *pucUsartTxBuff++;
//  289     //    UCSR0B |= (1 << TXEN0) | (1 << TXCIE0);
//  290     *m_UCSRA |= (1 << TXC0) | (1 << UDRE0);
        LDI     R26, LOW(??m_UCSRA)
        LDI     R27, (??m_UCSRA) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        ORI     R16, 0x60
        ST      Z, R16
//  291     *m_UCSRB |= (1 << TXEN0) | (1 << UDRIE0);
        LDI     R26, LOW(??m_UCSRB)
        LDI     R27, (??m_UCSRB) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        ORI     R16, 0x28
        ST      Z, R16
//  292 
//  293     return 1;
        LDI     R16, 1
        LDI     R17, 0
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09
//  294 }
//  295 
//  296 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  297 int16_t CUart::Read(uint8_t *puiDestination, uint16_t uiLength)
??Read:
//  298 {
        RCALL   ?PROLOGUE6_L09
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        MOVW    R25:R24, R17:R16
        MOVW    R27:R26, R19:R18
//  299     m_bfByteIsReceived = 0;
        LDI     R16, 0
        STS     ??m_bfByteIsReceived, R16
//  300 
//  301     if (m_bfRxBuffOverflow)
        LDS     R16, ??m_bfRxBuffOverflow
        TST     R16
        BREQ    ??Read_2
//  302     {
//  303         return -1;
        LDI     R16, 255
        LDI     R17, 255
        RJMP    ??Read_3
//  304     }
//  305 
//  306     if (uiLength <= m_nuiRxBuffByteCounter)
??Read_2:
        LDI     R30, LOW(??m_nuiRxBuffByteCounter)
        LDI     R31, (??m_nuiRxBuffByteCounter) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        CP      R16, R26
        CPC     R17, R27
        BRCS    ??Read_4
//  307     {
//  308         return -1;
        LDI     R16, 255
        LDI     R17, 255
        RJMP    ??Read_3
//  309     }
//  310     else if (m_nuiRxBuffByteCounter)
??Read_4:
        LDI     R30, LOW(??m_nuiRxBuffByteCounter)
        LDI     R31, (??m_nuiRxBuffByteCounter) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        OR      R16, R17
        BREQ    ??Read_5
//  311     {
//  312 //        *m_UCSRB &= ~((1 << RXEN0) | (1 << RXCIE0));
//  313         CPlatform::InterruptDisable();
        RCALL   ??InterruptDisable
//  314 //
//  315         for (int16_t i = 0; i < m_nuiRxBuffByteCounter; i++)
        LDI     R16, 0
        LDI     R17, 0
??Read_6:
        LDI     R30, LOW(??m_nuiRxBuffByteCounter)
        LDI     R31, (??m_nuiRxBuffByteCounter) >> 8
        LD      R18, Z
        LDD     R19, Z+1
        CP      R16, R18
        CPC     R17, R19
        BRCC    ??Read_7
//  316         {
//  317             puiDestination[i] = m_auiIntermediateBuff[i];
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(??m_auiIntermediateBuff) & 0xFFFF))
        SBCI    R31, (-(??m_auiIntermediateBuff) & 0xFFFF) >> 8
        LD      R18, Z
        MOVW    R31:R30, R25:R24
        ADD     R30, R16
        ADC     R31, R17
        ST      Z, R18
//  318         }
        SUBI    R16, 255
        SBCI    R17, 255
        RJMP    ??Read_6
//  319 
//  320         uint8_t uiCounter = m_nuiRxBuffByteCounter;
??Read_7:
        LDI     R30, LOW(??m_nuiRxBuffByteCounter)
        LDI     R31, (??m_nuiRxBuffByteCounter) >> 8
        LD      R4, Z
        LDD     R5, Z+1
//  321         m_nuiRxBuffByteCounter = 0;
        LDI     R30, LOW(??m_nuiRxBuffByteCounter)
        LDI     R31, (??m_nuiRxBuffByteCounter) >> 8
        LDI     R16, 0
        ST      Z, R16
        LDI     R16, 0
        STD     Z+1, R16
//  322 
//  323 //        *m_UCSRB |= (1 << RXEN0) | (1 << RXCIE0);
//  324         CPlatform::InterruptEnable();
        RCALL   ??InterruptEnable
//  325 
//  326         return uiCounter;
        MOV     R16, R4
        LDI     R17, 0
        RJMP    ??Read_3
//  327     }
//  328     else if (0 == m_nuiRxBuffByteCounter)
??Read_5:
        LDI     R30, LOW(??m_nuiRxBuffByteCounter)
        LDI     R31, (??m_nuiRxBuffByteCounter) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        OR      R16, R17
        BRNE    ??Read_8
//  329     {
//  330         return 0;
        LDI     R16, 0
        LDI     R17, 0
        RJMP    ??Read_3
//  331     }
//  332     return 0;
??Read_8:
        LDI     R16, 0
        LDI     R17, 0
??Read_3:
        LDI     R30, 6
        RJMP    ?EPILOGUE_B6_L09
//  333 }
//  334 
//  335 ////-----------------------------------------------------------------------------------------------------
//  336 //int16_t CUart::Read(uint8_t *puiDestination)
//  337 //{
//  338 //    if (m_bfByteIsReceived)
//  339 //    {
//  340 //        m_bfByteIsReceived = 0;
//  341 //
//  342 //        m_puiRxBuffer = puiDestination;
//  343 //
//  344 //        if (m_bfRxBuffOverflow)
//  345 //        {
//  346 //            return -1;
//  347 //        }
//  348 //
//  349 //        if ((UART_INTERMEDIATE_BUFFER_LENGTH - 1) <= m_nuiRxBuffByteCounter)
//  350 //        {
//  351 //            return -1;
//  352 //        }
//  353 //        else if (m_nuiRxBuffByteCounter)
//  354 //        {
//  355 //
//  356 ////            for (int16_t i = 0; i < m_nuiRxBuffByteCounter; i++)
//  357 ////            {
//  358 ////                pucDestination[i] = m_auiIntermediateBuff[i];
//  359 ////            }
//  360 ////
//  361 ////            uint8_t uiCounter = m_nuiRxBuffByteCounter;
//  362 ////            m_nuiRxBuffByteCounter = 0;
//  363 ////            return uiCounter;
//  364 //            return m_nuiRxBuffByteCounter;
//  365 //        }
//  366 //        else if (0 == m_nuiRxBuffByteCounter)
//  367 //        {
//  368 //            return 0;
//  369 //        }
//  370 //    }
//  371 //    return 0;
//  372 //}
//  373 
//  374 ////-----------------------------------------------------------------------------------------------------
//  375 //int16_t CUart::Read(void)
//  376 //{
//  377 //    if (m_bfByteIsReceived)
//  378 //    {
//  379 //        m_bfByteIsReceived = 0;
//  380 //
//  381 //        if (m_bfRxBuffOverflow)
//  382 //        {
//  383 //            return -1;
//  384 //        }
//  385 //
//  386 //        if ((UART_INTERMEDIATE_BUFFER_LENGTH - 1) <= m_nuiRxBuffByteCounter)
//  387 //        {
//  388 //            return -1;
//  389 //        }
//  390 //        else if (m_nuiRxBuffByteCounter)
//  391 //        {
//  392 //            return m_nuiRxBuffByteCounter;
//  393 //        }
//  394 //        else if (0 == m_nuiRxBuffByteCounter)
//  395 //        {
//  396 //            return 0;
//  397 //        }
//  398 //    }
//  399 //    return 0;
//  400 //}
//  401 
//  402 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  403 void CUart::UdreInterruptHandler(void)
??UdreInterruptHandler:
//  404 {
        RCALL   ?PROLOGUE4_L09
//  405     if (m_nuiTxBuffByteCounter == 0)
        LDI     R30, LOW(??m_nuiTxBuffByteCounter)
        LDI     R31, (??m_nuiTxBuffByteCounter) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        OR      R16, R17
        BRNE    ??UdreInterruptHandler_1
//  406     {
//  407         *m_UCSRB &= ~((1 << UDRIE0));
        LDI     R26, LOW(??m_UCSRB)
        LDI     R27, (??m_UCSRB) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        ANDI    R16, 0xDF
        ST      Z, R16
//  408         *m_UCSRA |= (1 << TXC0);
        LDI     R26, LOW(??m_UCSRA)
        LDI     R27, (??m_UCSRA) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        ORI     R16, 0x40
        ST      Z, R16
//  409         *m_UCSRB |= (1 << TXCIE0);
        LDI     R26, LOW(??m_UCSRB)
        LDI     R27, (??m_UCSRB) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        ORI     R16, 0x40
        ST      Z, R16
//  410         return;
        RJMP    ??UdreInterruptHandler_2
//  411     }
//  412     *m_UDR = *m_puiTxBuffer++;
??UdreInterruptHandler_1:
        LDI     R26, LOW(??m_puiTxBuffer)
        LDI     R27, (??m_puiTxBuffer) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        LDI     R26, LOW(??m_UDR)
        LDI     R27, (??m_UDR) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        ST      Z, R16
        LDI     R30, LOW(??m_puiTxBuffer)
        LDI     R31, (??m_puiTxBuffer) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        SUBI    R16, 255
        SBCI    R17, 255
        ST      Z, R16
        STD     Z+1, R17
//  413     m_nuiTxBuffByteCounter--;
        LDI     R30, LOW(??m_nuiTxBuffByteCounter)
        LDI     R31, (??m_nuiTxBuffByteCounter) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        SUBI    R16, 1
        SBCI    R17, 0
        ST      Z, R16
        STD     Z+1, R17
//  414 }
??UdreInterruptHandler_2:
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09
//  415 
//  416 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  417 void CUart::TxcInterruptHandler(void)
??TxcInterruptHandler:
//  418 {
        RCALL   ?PROLOGUE4_L09
//  419     *m_UCSRB &= ~((1 << TXEN0) | (1 << TXCIE0));
        LDI     R26, LOW(??m_UCSRB)
        LDI     R27, (??m_UCSRB) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        ANDI    R16, 0xB7
        ST      Z, R16
//  420 
//  421 //    if (m_rs485ddr)
//  422 //    {
//  423 //        Rs485RtsOff();
//  424 //    }
//  425     CMvsn21::MeasureFlowControlSet(CMvsn21::FSM_START);
        LDI     R16, 1
        RCALL   ??MeasureFlowControlSet
//  426     *m_UCSRA |= (1 << RXC0);
        LDI     R26, LOW(??m_UCSRA)
        LDI     R27, (??m_UCSRA) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        ORI     R16, 0x80
        ST      Z, R16
//  427     *m_UCSRB |= (1 << RXEN0) | (1 << RXCIE0);
        LDI     R26, LOW(??m_UCSRB)
        LDI     R27, (??m_UCSRB) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        ORI     R16, 0x90
        ST      Z, R16
//  428     m_bfFrameIsSended = 1;
        LDI     R16, 1
        STS     ??m_bfFrameIsSended, R16
//  429     return;
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09
//  430 }
//  431 
//  432 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  433 void CUart::RecvInterruptHandler(void)
??RecvInterruptHandler:
//  434 {
        RCALL   ?PROLOGUE4_L09
//  435     // промежуточный буфер приёма переполнен?
//  436     if (m_nuiRxBuffByteCounter >=
//  437             UART_MAX_BUFF_LENGTH)
        LDI     R30, LOW(??m_nuiRxBuffByteCounter)
        LDI     R31, (??m_nuiRxBuffByteCounter) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        CPI     R16, 64
        LDI     R18, 0
        CPC     R17, R18
        BRCS    ??RecvInterruptHandler_1
//  438     {
//  439         m_bfRxBuffOverflow = 1;
        LDI     R16, 1
        STS     ??m_bfRxBuffOverflow, R16
//  440         // не инкрементируем pucUsartRxBuff, чтобы не выйти за границы буфера.
//  441         m_bfByteIsReceived = 1;
        LDI     R16, 1
        STS     ??m_bfByteIsReceived, R16
        RJMP    ??RecvInterruptHandler_2
//  442     }
//  443     else
//  444     {
//  445 //        m_puiRxBuffer[m_nuiRxBuffByteCounter++] = *m_UDR;
//  446         m_auiIntermediateBuff[m_nuiRxBuffByteCounter++] = *m_UDR;
??RecvInterruptHandler_1:
        LDI     R26, LOW(??m_UDR)
        LDI     R27, (??m_UDR) >> 8
        LD      R30, X+
        LD      R31, X
        SBIW    R27:R26, 1
        LD      R16, Z
        LDI     R30, LOW(??m_nuiRxBuffByteCounter)
        LDI     R31, (??m_nuiRxBuffByteCounter) >> 8
        LD      R18, Z
        LDD     R19, Z+1
        MOVW    R31:R30, R19:R18
        SUBI    R30, LOW((-(??m_auiIntermediateBuff) & 0xFFFF))
        SBCI    R31, (-(??m_auiIntermediateBuff) & 0xFFFF) >> 8
        ST      Z, R16
        LDI     R30, LOW(??m_nuiRxBuffByteCounter)
        LDI     R31, (??m_nuiRxBuffByteCounter) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        SUBI    R16, 255
        SBCI    R17, 255
        ST      Z, R16
        STD     Z+1, R17
//  447         m_bfByteIsReceived = 1;
        LDI     R16, 1
        STS     ??m_bfByteIsReceived, R16
//  448     }
//  449 }
??RecvInterruptHandler_2:
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09
//  450 
//  451 //-----------------------------------------------------------------------------------------------------
//  452 // Прерывание по пустому регистру данных UDR
//  453 #pragma vector = USART_UDRE_vect

        RSEG CODE:CODE:NOROOT(1)
        CALL_GRAPH_ROOT ??SIG_UART0_DATA, "interrupt"
//  454 __interrupt void SIG_UART0_DATA(void)
??SIG_UART0_DATA:
//  455 {
        ST      -Y, R31
        ST      -Y, R30
        ST      -Y, R0
        ST      -Y, R18
        ST      -Y, R17
        ST      -Y, R16
        IN      R18, 0x3F
//  456     CUart::UdreInterruptHandler();
        RCALL   ??UdreInterruptHandler
//  457 }
        OUT     0x3F, R18
        LD      R16, Y+
        LD      R17, Y+
        LD      R18, Y+
        LD      R0, Y+
        LD      R30, Y+
        LD      R31, Y+
        RETI
//  458 
//  459 //-----------------------------------------------------------------------------------------------------
//  460 // Прерывание по завершению передачи UART
//  461 #pragma vector = USART_TX_vect

        RSEG CODE:CODE:NOROOT(1)
        CALL_GRAPH_ROOT ??SIG_UART0_TXC, "interrupt"
//  462 __interrupt void SIG_UART0_TXC(void)
??SIG_UART0_TXC:
//  463 {
        ST      -Y, R24
        ST      -Y, R31
        ST      -Y, R30
        ST      -Y, R3
        ST      -Y, R2
        ST      -Y, R1
        ST      -Y, R0
        ST      -Y, R23
        ST      -Y, R22
        ST      -Y, R21
        ST      -Y, R20
        ST      -Y, R19
        ST      -Y, R18
        ST      -Y, R17
        ST      -Y, R16
        IN      R24, 0x3F
//  464     CUart::TxcInterruptHandler();
        RCALL   ??TxcInterruptHandler
//  465 }
        OUT     0x3F, R24
        LD      R16, Y+
        LD      R17, Y+
        LD      R18, Y+
        LD      R19, Y+
        LD      R20, Y+
        LD      R21, Y+
        LD      R22, Y+
        LD      R23, Y+
        LD      R0, Y+
        LD      R1, Y+
        LD      R2, Y+
        LD      R3, Y+
        LD      R30, Y+
        LD      R31, Y+
        LD      R24, Y+
        RETI
//  466 
//  467 //-----------------------------------------------------------------------------------------------------
//  468 // Прерывание по завершению приема UART
//  469 #pragma vector = USART_RX_vect

        RSEG CODE:CODE:NOROOT(1)
        CALL_GRAPH_ROOT ??SIG_UART0_RECV, "interrupt"
//  470 __interrupt void SIG_UART0_RECV(void)
??SIG_UART0_RECV:
//  471 {
        ST      -Y, R31
        ST      -Y, R30
        ST      -Y, R0
        ST      -Y, R20
        ST      -Y, R19
        ST      -Y, R18
        ST      -Y, R17
        ST      -Y, R16
        IN      R20, 0x3F
//  472     CUart::RecvInterruptHandler();
        RCALL   ??RecvInterruptHandler
//  473 }
        OUT     0x3F, R20
        LD      R16, Y+
        LD      R17, Y+
        LD      R18, Y+
        LD      R19, Y+
        LD      R20, Y+
        LD      R0, Y+
        LD      R30, Y+
        LD      R31, Y+
        RETI
//  474 
//  475 //-----------------------------------------------------------------------------------------------------
//  476 
//  477 
//  478 
//  479 
//  480 
//  481 ////----------------------------------------- EEPROM ----------------------------------------------------------------
//  482 //CEeprom::CEeprom()
//  483 //{
//  484 //
//  485 //}
//  486 //
//  487 ////-----------------------------------------------------------------------------------------------------
//  488 //CEeprom::~CEeprom()
//  489 //{
//  490 //
//  491 //}
//  492 
//  493 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  494 uint8_t CEeprom::ReadByte(uint16_t ui16EepromSourse)
??ReadByte:
//  495 {
        MOVW    R19:R18, R17:R16
//  496     __watchdog_reset();
        WDR
//  497     while (BitIsSet(EECR, EEPE))
??ReadByte_1:
        SBIS    0x1F, 0x01
        RJMP    ??ReadByte_2
//  498     {
//  499         __watchdog_reset();
        WDR
        RJMP    ??ReadByte_1
//  500     }
//  501     __disable_interrupt();
??ReadByte_2:
        CLI
//  502     EEAR = ui16EepromSourse;
        OUT     0x22, R19
        OUT     0x21, R18
//  503     SetBit(EECR, EERE);
        SBI     0x1F, 0x00
//  504     __enable_interrupt();
        SEI
//  505     return EEDR;
        IN      R16, 0x20
        RET
        REQUIRE _A_EECR
        REQUIRE _A_EEAR
        REQUIRE _A_EEDR
//  506 }
//  507 
//  508 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  509 void CEeprom::WriteByte(uint16_t ui16EepromDestination, uint8_t ucData)
??WriteByte:
//  510 {
//  511     __watchdog_reset();
        WDR
//  512     while (BitIsSet(EECR, EEPE))
??WriteByte_1:
        SBIS    0x1F, 0x01
        RJMP    ??WriteByte_2
//  513     {
//  514         __watchdog_reset();
        WDR
        RJMP    ??WriteByte_1
//  515     }
//  516     __disable_interrupt();
??WriteByte_2:
        CLI
//  517     EEAR = ui16EepromDestination;
        OUT     0x22, R17
        OUT     0x21, R16
//  518     EEDR = ucData;
        OUT     0x20, R18
//  519     EECR |= (1<<EEMPE);
        SBI     0x1F, 0x02
//  520     EECR |= (1<<EEPE);
        SBI     0x1F, 0x01
//  521     __enable_interrupt();
        SEI
//  522 }
        RET
        REQUIRE _A_EECR
        REQUIRE _A_EEAR
        REQUIRE _A_EEDR
//  523 
//  524 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  525 uint8_t CEeprom::Read(uint8_t *pucRamDestination, uint16_t uiEepromSourse, uint16_t nuiLength)
??Read_1:
//  526 {
        RCALL   ?PROLOGUE2_L09
        MOVW    R31:R30, R17:R16
        MOVW    R25:R24, R19:R18
//  527     while (nuiLength != 0)
??Read_9:
        MOV     R16, R20
        OR      R16, R21
        BREQ    ??Read_10
//  528     {
//  529         *pucRamDestination++ = ReadByte(uiEepromSourse++);
        MOVW    R17:R16, R25:R24
        RCALL   ??ReadByte
        ADIW    R25:R24, 1
        ST      Z, R16
        ADIW    R31:R30, 1
//  530         nuiLength--;
        SUBI    R20, 1
        SBCI    R21, 0
        RJMP    ??Read_9
//  531     }
//  532     return 1;
??Read_10:
        LDI     R16, 1
        LDI     R30, 2
        RJMP    ?EPILOGUE_B2_L09
//  533 }
//  534 
//  535 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  536 uint8_t CEeprom::Write(uint16_t uiEepromDestination, uint8_t *pucRamSourse, uint16_t nuiLength)
??Write_1:
//  537 {
        RCALL   ?PROLOGUE2_L09
        MOVW    R25:R24, R17:R16
        MOVW    R23:R22, R19:R18
//  538     while (nuiLength != 0)
??Write_2:
        MOV     R16, R20
        OR      R16, R21
        BREQ    ??Write_3
//  539     {
//  540         WriteByte((uiEepromDestination++), (*pucRamSourse++));
        MOVW    R31:R30, R23:R22
        MOVW    R23:R22, R31:R30
        SUBI    R22, 255
        SBCI    R23, 255
        LD      R18, Z
        MOVW    R17:R16, R25:R24
        RCALL   ??WriteByte
        ADIW    R25:R24, 1
//  541         nuiLength--;
        SUBI    R20, 1
        SBCI    R21, 0
        RJMP    ??Write_2
//  542     }
//  543     return 1;
??Write_3:
        LDI     R16, 1
        LDI     R30, 2
        RJMP    ?EPILOGUE_B2_L09
//  544 }
//  545 //-----------------------------------------------------------------------------------------------------
//  546 
//  547 
//  548 
//  549 
//  550 
//  551 ////----------------------------------------- CSpi ----------------------------------------------------------------
//  552 //uint8_t CSpi::m_uiExchangeByte;
//  553 //uint8_t* CSpi::m_puiRxBuffer;
//  554 //uint8_t* CSpi::m_puiTxBuffer;
//  555 //uint16_t CSpi::m_nuiBuffByteCounter;
//  556 //uint16_t CSpi::m_uiReceivedByteCounter;
//  557 //bool CSpi::m_bfByteIsReceived;
//  558 //bool CSpi::m_bfByteIsTransmited;
//  559 //bool CSpi::m_bfDataExchangeInProgress;
//  560 //bool CSpi::m_bfDataExchangeIsOccur;
//  561 //bool CSpi::m_bfRxBuffOverflow;
//  562 //uint8_t CSpi::m_auiSpiRxBuffer[];
//  563 //uint8_t CSpi::m_auiSpiTxBuffer[];
//  564 //
//  565 ////-----------------------------------------------------------------------------------------------------
//  566 //CSpi::CSpi()
//  567 //{
//  568 //
//  569 //}
//  570 //
//  571 ////-----------------------------------------------------------------------------------------------------
//  572 //CSpi::~CSpi()
//  573 //{
//  574 //
//  575 //}
//  576 //
//  577 ////-----------------------------------------------------------------------------------------------------
//  578 //void CSpi::Init(uint8_t *puiRxBuffer, uint8_t *puiTxBuffer)
//  579 //{
//  580 ////    m_puiRxBuffer = m_auiSpiRxBuffer;
//  581 ////    m_puiTxBuffer = m_auiSpiTxBuffer;
//  582 //    m_puiRxBuffer = puiRxBuffer;
//  583 //    m_puiTxBuffer = puiTxBuffer;
//  584 ////    // Master mode.
//  585 ////    SPCR = 0;
//  586 ////    SPCR  |= (BIT(SPR1));		// Slave,  57600.
//  587 ////
//  588 ////    DDRB  |= (BIT(SPI_MOSI));
//  589 //
//  590 //    // Slave mode.
//  591 //    DDRB  |= (Bit(SPI_MISO) | Bit(DDB1));
//  592 //    SPCR |= (1 << SPR1);
//  593 //};
//  594 //
//  595 ////-----------------------------------------------------------------------------------------------------
//  596 //void CSpi::Enable(void)
//  597 //{
//  598 ////    // Slave mode.
//  599 ////    DDRB  |= (Bit(SPI_MISO) | Bit(DDB1));
//  600 //    // разрешим SS.
//  601 //    PORTB &= ~Bit(PB1);
//  602 //    // разрешим SPI.
//  603 //    // разрешим прерывание SPI_STC.
//  604 //    SPCR |= ((1 << SPE) | (1 << SPIE));
//  605 //    SPDR = 0;
//  606 //}
//  607 //
//  608 ////-----------------------------------------------------------------------------------------------------
//  609 //void CSpi::Disable(void)
//  610 //{
//  611 //    // Slave mode.
//  612 ////    // запретим прерывание SPI_STC.
//  613 ////    PORTB &= ~(Bit(SPI_MOSI) | Bit(SPI_MISO) | Bit(SPI_SCK));
//  614 ////    DDRB  &= ~(Bit(SPI_MOSI) | Bit(SPI_MISO) | Bit(SPI_SCK));
//  615 //    // запретим SS.
//  616 //    PORTB |= Bit(PB1);
//  617 //    SPCR &= ~((1 << SPE) | (1 << SPIE));
//  618 //}
//  619 //
//  620 ////-----------------------------------------------------------------------------------------------------
//  621 //void CSpi::Reset(void)
//  622 //{
//  623 //    m_nuiBuffByteCounter = 0;
//  624 //    m_uiReceivedByteCounter = 0;
//  625 //    m_bfByteIsReceived = 0;
//  626 //    m_bfByteIsTransmited = 0;
//  627 //    m_bfDataExchangeInProgress = 0;
//  628 //    m_bfDataExchangeIsOccur = 0;
//  629 //    m_bfRxBuffOverflow = 0;
//  630 //    m_uiExchangeByte = 0;
//  631 //}
//  632 //
//  633 ////-----------------------------------------------------------------------------------------------------
//  634 //int16_t CSpi::Exchange(void)
//  635 //{
//  636 //    m_bfByteIsReceived = 0;
//  637 //
//  638 //    if (m_bfRxBuffOverflow)
//  639 //    {
//  640 //        return -1;
//  641 //    }
//  642 //    if (BUFFER_LENGTH <= m_nuiBuffByteCounter)
//  643 //    {
//  644 //        return -1;
//  645 //    }
//  646 //    else if (m_nuiBuffByteCounter)
//  647 //    {
//  648 ////        CPlatform::InterruptDisable();
//  649 //
//  650 ////        *puiDestination = m_uiExchangeByte;
//  651 ////        m_uiExchangeByte = 0x78;//*puiSourse;
//  652 //
//  653 //        uint8_t uiCounter = m_nuiBuffByteCounter;
//  654 ////        m_nuiBuffByteCounter = 0;
//  655 //
//  656 ////        CPlatform::InterruptEnable();
//  657 //
//  658 //        return uiCounter;
//  659 //    }
//  660 //    else if (0 == m_nuiBuffByteCounter)
//  661 //    {
//  662 //        return 0;
//  663 //    }
//  664 //
//  665 //    return 0;
//  666 //}
//  667 //
//  668 ////-----------------------------------------------------------------------------------------------------
//  669 //uint8_t CSpi::Read(uint8_t *pucRamDestination, uint16_t uiEepromSourse, uint16_t nuiLength)
//  670 //{
//  671 //
//  672 //    return 1;
//  673 //}
//  674 //
//  675 ////-----------------------------------------------------------------------------------------------------
//  676 //void CSpi::RecvInterruptHandler(void)
//  677 //{
//  678 ////    SPDR = m_uiExchangeByte;
//  679 ////    m_uiExchangeByte = SPDR;
//  680 ////    // буфер приёма не переполнен?
//  681 ////    if (m_nuiBuffByteCounter <
//  682 ////            SPI_MAX_BUFF_LENGTH)
//  683 ////    {
//  684 ////        m_nuiBuffByteCounter++;
//  685 ////        m_bfByteIsReceived = 1;
//  686 ////    }
//  687 ////    else
//  688 ////    {
//  689 ////        // не инкрементируем m_nuiBuffByteCounter, чтобы не выйти за границы буфера.
//  690 ////        // установим флаг - произошел обмен данными по SPI.
//  691 ////        m_bfRxBuffOverflow = 1;
//  692 ////        m_bfByteIsReceived = 1;
//  693 ////    }
//  694 //
//  695 //
//  696 ////    SPDR = m_uiExchangeByte;
//  697 ////    m_puiRxBuffer[m_nuiBuffByteCounter] = SPDR;
//  698 ////    m_uiExchangeByte = m_puiTxBuffer[m_nuiBuffByteCounter];
//  699 ////    // буфер приёма не переполнен?
//  700 ////    if (m_nuiBuffByteCounter <
//  701 ////            SPI_MAX_BUFF_LENGTH)
//  702 ////    {
//  703 ////        m_nuiBuffByteCounter++;
//  704 ////        m_bfByteIsReceived = 1;
//  705 ////    }
//  706 ////    else
//  707 ////    {
//  708 ////        // не инкрементируем m_nuiBuffByteCounter, чтобы не выйти за границы буфера.
//  709 ////        // установим флаг - произошел обмен данными по SPI.
//  710 ////        m_bfRxBuffOverflow = 1;
//  711 ////        m_bfByteIsReceived = 1;
//  712 ////    }
//  713 //}
//  714 
//  715 ////-----------------------------------------------------------------------------------------------------
//  716 //#pragma vector = SPI_STC_vect
//  717 //__interrupt void SIG_SPI_STC(void)
//  718 //{
//  719 ////    if (CSpi::m_bfByteIsTransmited)
//  720 ////    {
//  721 ////        SPDR = CSpi::m_uiExchangeByte;
//  722 ////    }
//  723 ////    else
//  724 ////    {
//  725 ////        // Первый байт не передаём, чтобы прошло "эхо".
//  726 ////        CSpi::m_bfByteIsTransmited = 1;
//  727 ////        SPDR = SPDR;//0x91;//
//  728 ////    }
//  729 //    SPDR = CSpi::m_uiExchangeByte;
//  730 //    CSpi::m_puiRxBuffer[CSpi::m_nuiBuffByteCounter] = SPDR;
//  731 //    CSpi::m_uiExchangeByte = CSpi::m_puiTxBuffer[CSpi::m_nuiBuffByteCounter + 1];
//  732 //
//  733 //    // буфер приёма не переполнен?
//  734 //    if (CSpi::m_nuiBuffByteCounter <
//  735 //            CSpi::BUFFER_LENGTH)
//  736 //    {
//  737 //        CSpi::m_nuiBuffByteCounter++;
//  738 //        CSpi::m_bfByteIsReceived = 1;
//  739 //    }
//  740 //    else
//  741 //    {
//  742 //        // не инкрементируем m_nuiBuffByteCounter, чтобы не выйти за границы буфера.
//  743 //        // установим флаг - произошел обмен данными по SPI.
//  744 //        CSpi::m_bfRxBuffOverflow = 1;
//  745 //        CSpi::m_bfByteIsReceived = 1;
//  746 //    }
//  747 //}
//  748 
//  749 //-----------------------------------------------------------------------------------------------------
//  750 
//  751 
//  752 
//  753 
//  754 
//  755 //-----------------------------------------------------------------------------------------------------
//  756 //// delay
//  757 //void delay_ms(uint16_t millisecs)
//  758 //{
//  759 //    while(millisecs--)
//  760 //    {
//  761 //        delay_us(1000);
//  762 //    }
//  763 //}
//  764 //void delay_s(uint16_t secs)
//  765 //{
//  766 //    while(secs--)
//  767 //    {
//  768 //        __delay_cycles(F_CPU);
//  769 //    }
//  770 //}
//  771 //void delay_mins(uint16_t minutes)
//  772 //{
//  773 //    while(minutes--)
//  774 //    {
//  775 //        __delay_cycles(60*F_CPU);
//  776 //    }
//  777 //}
//  778 
//  779 //-----------------------------------------------------------------------------------------------------

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  780 uint16_t CPlatform::m_uiSystemTick;
??m_uiSystemTick:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  781 CUart* CPlatform::m_pxUart0;
??m_pxUart0:
        DS8 2

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  782 CUart* CPlatform::m_pxUart1;
??m_pxUart1:
        DS8 2
//  783 //CSpi* CPlatform::m_pxSpi;

        RSEG NEAR_Z:DATA:ROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//  784 uint8_t CPlatform::uiSlaveSelectIsHigh;
??uiSlaveSelectIsHigh:
        DS8 1
//  785 
//  786 ////-----------------------------------------------------------------------------------------------------
//  787 //CPlatform::CPlatform()
//  788 //{
//  789 //
//  790 //}
//  791 //
//  792 ////-----------------------------------------------------------------------------------------------------
//  793 //CPlatform::~CPlatform()
//  794 //{
//  795 //
//  796 //}
//  797 
//  798 ////-----------------------------------------------------------------------------------------------------
//  799 //// INT0
//  800 ////-----------------------------------------------------------------------------------------------------
//  801 //void CPlatform::Int0InterruptEnable(void)
//  802 //{
//  803 //    // установим прерывание INT0 по переднему фронту(ожидание конца обмена данными по SPI).
//  804 //    EICRA &= ~(Bit(ISC01) | Bit(ISC00));
//  805 //    EICRA |= (Bit(ISC01) | Bit(ISC00));
//  806 //    // разрешение внешнего прерывания INT0.
//  807 //    EIMSK |= Bit(INT0);
//  808 //}
//  809 ////-----------------------------------------------------------------------------------------------------
//  810 //void CPlatform::Int0InterruptDisable(void)
//  811 //{
//  812 //    // запретим внешнее прерывание INT0.
//  813 //    EIMSK &= ~Bit(INT0);
//  814 //}
//  815 //
//  816 ////-----------------------------------------------------------------------------------------------------
//  817 //#pragma vector = INT0_vect
//  818 //__interrupt void SIG_INT0(void)
//  819 //{
//  820 //    // прерывание INT0 произошло по переднему фронту(закончен обмен данными по SPI)?
//  821 //    if (!(BIT_IS_SET(PIND, SPI_SS5)))
//  822 //    {
//  823 //        // прерывание INT0 произошло по переднему фронту(закончен обмен данными по SPI).
//  824 //        // установим флаг - вход SS0 переходил в 1(запущен демон ПАС).
//  825 //        CPlatform::uiSlaveSelectIsHigh = 1;
//  826 //        CSpi::DataExchangeInProgressClear();
//  827 //        // запретим SPI.
//  828 //        CSpi::Disable();
//  829 //        // установим прерывание INT0 по переднему фронту(ожидание конца обмена данными по SPI).
//  830 //        EICRA &= ~(Bit(ISC01) | Bit(ISC00));
//  831 //        EICRA |= (Bit(ISC01) | Bit(ISC00));
//  832 //        // установим флаг - произошел обмен данными по SPI.
//  833 //        CSpi::DataExchangeIsOccurSet();
//  834 //        CMvsn21::FlowControlSet(CMvsn21::FSM_IDDLE);
//  835 //        CPlatform::TxLedOff();
//  836 //    }
//  837 //    else
//  838 //    {
//  839 //        CSpi::DataExchangeInProgressSet();
//  840 //        CSpi::Enable();
//  841 //        // установим прерывание INT0 по заднему фронту(ожидание начала обмена данными по SPI).
//  842 //        EICRA &= ~(Bit(ISC01) | Bit(ISC00));
//  843 //        EICRA |= (Bit(ISC01));
//  844 //        CMvsn21::FlowControlSet(CMvsn21::FSM_START);
//  845 //        CMvsn21::MeasureFlowControlSet(CMvsn21::FSM_START);
//  846 //        CPlatform::TxLedOn();
//  847 //    }
//  848 //}
//  849 
//  850 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  851 void SystemTickInit(void)
??SystemTickInit:
//  852 {
//  853 #define MAIN_TIMER_TICK_RATE_HZ 1000
//  854 
//  855 //#define TIMER1_INTERRUPT
//  856 #define TIMER2_INTERRUPT
//  857 
//  858 
//  859 #ifdef TIMER2_INTERRUPT
//  860     /* Hardware constants for timer 2. */
//  861 #define portCLEAR_COUNTER_ON_MATCH              ( ( unsigned char ) _BV(WGM21) )
//  862 #define portPRESCALE_64                         ( ( unsigned char ) (_BV(CS21) | _BV(CS20)) )
//  863 #define portCLOCK_PRESCALER                     ( ( unsigned long ) 64 )
//  864 #define portCOMPARE_MATCH_A_INTERRUPT_ENABLE    ( ( unsigned char ) _BV(OCIE2A) )
//  865 #endif //TIMER2_INTERRUPT
//  866 
//  867 #ifdef TIMER1_INTERRUPT
//  868     /* Hardware constants for timer 1. */
//  869 #define portCLEAR_COUNTER_ON_MATCH              ( ( unsigned char ) _BV(WGM12) )
//  870 #define portPRESCALE_64                         ( ( unsigned char ) (_BV(CS11) | _BV(CS10)) )
//  871 #define portCLOCK_PRESCALER                     ( ( unsigned long ) 64 )
//  872 #define portCOMPARE_MATCH_A_INTERRUPT_ENABLE    ( ( unsigned char ) _BV(OCIE1A) )
//  873 #endif //TIMER1_INTERRUPT
//  874 
//  875 #ifdef TIMER2_INTERRUPT
//  876 
//  877     OCR2A = (((F_CPU / MAIN_TIMER_TICK_RATE_HZ) / 128) - 1);
        LDI     R16, 56
        STS     _A_OCR2A, R16
//  878     TCCR2A |= (Bit(WGM21));
        LDS     R16, 176
        ORI     R16, 0x02
        STS     176, R16
//  879     TCCR2B |= (Bit(CS22) | Bit(CS20));
        LDS     R16, _A_TCCR2B
        ORI     R16, 0x05
        STS     _A_TCCR2B, R16
//  880 
//  881     TIMSK2 |= Bit(OCIE2A);
        LDS     R16, 112
        ORI     R16, 0x02
        STS     112, R16
//  882 
//  883 #endif //TIMER2_INTERRUPT
//  884 
//  885 #ifdef TIMER1_INTERRUPT
//  886 
//  887     unsigned long ulCompareMatch;
//  888     unsigned char ucLowByte;
//  889 
//  890     /* Using 16bit timer 1 to generate the tick.  Correct fuses must be
//  891     selected for the configCPU_CLOCK_HZ clock. */
//  892 
//  893     ulCompareMatch = CPlatform::F_CPU / MAIN_TIMER_TICK_RATE_HZ;
//  894 
//  895     /* We only have 16 bits so have to scale to get our required tick rate. */
//  896     ulCompareMatch /= portCLOCK_PRESCALER;
//  897 
//  898     /* Adjust for correct value. */
//  899     ulCompareMatch -= ( unsigned long ) 1;
//  900 
//  901     /* Setup compare match value for compare match A.  Interrupts are disabled
//  902     before this is called so we need not worry here. */
//  903     OCR1A = ulCompareMatch;
//  904 
//  905     /* Setup clock source and compare match behaviour. */
//  906     TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));
//  907     ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
//  908     TCCR1B = ucLowByte;
//  909 
//  910     /* Enable the interrupt - this is okay as interrupt are currently globally
//  911     disabled. */
//  912     ucLowByte = TIMSK;
//  913     ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
//  914     TIMSK = ucLowByte;
//  915 
//  916 #endif //TIMER1_INTERRUPT
//  917 
//  918 }
        RET
        REQUIRE _A_OCR2A
        REQUIRE _A_TCCR2A
        REQUIRE _A_TCCR2B
        REQUIRE _A_TIMSK2
//  919 
//  920 //-----------------------------------------------------------------------------------------------------
//  921 #ifdef TIMER1_INTERRUPT
//  922 // Прерывание TIMER1_COMPA_vect
//  923 __interrupt void SystemTickInterrupt(void)
//  924 {
//  925     CPlatform::IncrementSystemTick();
//  926 }
//  927 #endif //TIMER1_INTERRUPT
//  928 //-----------------------------------------------------------------------------------------------------
//  929 #ifdef TIMER2_INTERRUPT
//  930 // Прерывание TIMER2_COMP_vect
//  931 #pragma vector = TIMER2_COMPA_vect	// Прерывание по совпадению TMR2 с OCR2

        RSEG CODE:CODE:NOROOT(1)
        CALL_GRAPH_ROOT ??SystemTickInterrupt, "interrupt"
//  932 __interrupt void SystemTickInterrupt(void)
??SystemTickInterrupt:
//  933 {
        ST      -Y, R24
        ST      -Y, R31
        ST      -Y, R30
        ST      -Y, R3
        ST      -Y, R2
        ST      -Y, R1
        ST      -Y, R0
        ST      -Y, R23
        ST      -Y, R22
        ST      -Y, R21
        ST      -Y, R20
        ST      -Y, R19
        ST      -Y, R18
        ST      -Y, R17
        ST      -Y, R16
        IN      R24, 0x3F
//  934     CPlatform::IncrementSystemTick();
        RCALL   ??IncrementSystemTick
//  935 }
        OUT     0x3F, R24
        LD      R16, Y+
        LD      R17, Y+
        LD      R18, Y+
        LD      R19, Y+
        LD      R20, Y+
        LD      R21, Y+
        LD      R22, Y+
        LD      R23, Y+
        LD      R0, Y+
        LD      R1, Y+
        LD      R2, Y+
        LD      R3, Y+
        LD      R30, Y+
        LD      R31, Y+
        LD      R24, Y+
        RETI
//  936 #endif //TIMER2_INTERRUPT
//  937 
//  938 
//  939 
//  940 
//  941 //-----------------------------------------------------------------------------------------------------

        RSEG CODE:CODE:NOROOT(1)
//  942 void CPlatform::Init(void)
??Init_2:
//  943 {
//  944     SystemTickInit();
        RCALL   ??SystemTickInit
//  945 //    StatusLedSetPinOutput();
//  946 //    TxLedSetPinOutput();
//  947 }
        RET

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,020H
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,021H
__?EEARL:

        COMMON INTVEC:CODE:ROOT(1)
        ORG 14
`??SystemTickInterrupt::??INTVEC 14`:
        RJMP    ??SystemTickInterrupt

        COMMON INTVEC:CODE:ROOT(1)
        ORG 36
`??SIG_UART0_RECV::??INTVEC 36`:
        RJMP    ??SIG_UART0_RECV

        COMMON INTVEC:CODE:ROOT(1)
        ORG 38
`??SIG_UART0_DATA::??INTVEC 38`:
        RJMP    ??SIG_UART0_DATA

        COMMON INTVEC:CODE:ROOT(1)
        ORG 40
`??SIG_UART0_TXC::??INTVEC 40`:
        RJMP    ??SIG_UART0_TXC

        RSEG INITTAB:CODE:NOROOT(0)
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DC16    0
        REQUIRE ?need_segment_init

        END
//  948 
//  949 
//  950 
//  951 //
//  952 //        PUSH R16
//  953 //        LDS     R16, ??m_uiExchangeByte
//  954 //        OUT     0x0F, R16
//  955 //        POP R16
//  956 //
//  957 //        ST      -Y, R31
//  958 //          CFI R31 Frame(CFA_Y, -1)
//  959 //          CFI CFA_Y Y+1
//  960 //        ST      -Y, R30
//  961 //          CFI R30 Frame(CFA_Y, -2)
//  962 //          CFI CFA_Y Y+2
//  963 //        ST      -Y, R19
//  964 //          CFI R19 Frame(CFA_Y, -3)
//  965 //          CFI CFA_Y Y+3
//  966 //        ST      -Y, R18
//  967 //          CFI R18 Frame(CFA_Y, -4)
//  968 //          CFI CFA_Y Y+4
//  969 //        ST      -Y, R17
//  970 //          CFI R17 Frame(CFA_Y, -5)
//  971 //          CFI CFA_Y Y+5
//  972 //        ST      -Y, R16
//  973 //          CFI R16 Frame(CFA_Y, -6)
//  974 //          CFI CFA_Y Y+6
//  975 //        IN      R19, 0x3F
//  976 //;        LDS     R16, ??m_uiExchangeByte
//  977 //;        OUT     0x2E, R16
//  978 //        IN      R16, 0x2E
//  979 //        STS     ??m_uiExchangeByte, R16
//  980 //        LDS     R16, ??m_nuiBuffByteCounter
//  981 //        LDS     R17, (??m_nuiBuffByteCounter + 1)
//  982 //        CPI     R16, 0
//  983 //        LDI     R18, 1
//  984 //        CPC     R17, R18
//  985 //        BRCC    ??SIG_SPI_STC_1
//  986 //        LDI     R30, LOW(??m_nuiBuffByteCounter)
//  987 //        LDI     R31, (??m_nuiBuffByteCounter) >> 8
//  988 //        LD      R16, Z
//  989 //        LDD     R17, Z+1
//  990 //        SUBI    R16, 255
//  991 //        SBCI    R17, 255
//  992 //        ST      Z, R16
//  993 //        STD     Z+1, R17
//  994 //        LDI     R16, 1
//  995 //        STS     ??m_bfByteIsReceived, R16
//  996 //        RJMP    ??SIG_SPI_STC_2
//  997 //??SIG_SPI_STC_1:
//  998 //        LDI     R16, 1
//  999 //        STS     ??m_bfRxBuffOverflow, R16
// 1000 //        LDI     R16, 1
// 1001 //        STS     ??m_bfByteIsReceived, R16
// 1002 //??SIG_SPI_STC_2:
// 1003 //        OUT     0x3F, R19
// 1004 //        LD      R16, Y+
// 1005 //          CFI R16 SameValue
// 1006 //          CFI CFA_Y Y+5
// 1007 //        LD      R17, Y+
// 1008 //          CFI R17 SameValue
// 1009 //          CFI CFA_Y Y+4
// 1010 //        LD      R18, Y+
// 1011 //          CFI R18 SameValue
// 1012 //          CFI CFA_Y Y+3
// 1013 //        LD      R19, Y+
// 1014 //          CFI R19 SameValue
// 1015 //          CFI CFA_Y Y+2
// 1016 //        LD      R30, Y+
// 1017 //          CFI R30 SameValue
// 1018 //          CFI CFA_Y Y+1
// 1019 //        LD      R31, Y+
// 1020 //          CFI R31 SameValue
// 1021 //          CFI CFA_Y Y+0
// 1022 //        RETI
// 
//    87 bytes in segment ABSOLUTE
// 1 484 bytes in segment CODE
//     6 bytes in segment INITTAB
//     8 bytes in segment INTVEC
//    53 bytes in segment NEAR_Z
// 
// 1 452 bytes of CODE memory (+ 46 bytes shared)
//    53 bytes of DATA memory (+ 87 bytes shared)
//
//Errors: none
//Warnings: 1
